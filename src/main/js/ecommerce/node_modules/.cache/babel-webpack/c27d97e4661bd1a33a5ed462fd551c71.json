{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines an {@linkplain cmd.Executor command executor} that\n * communicates with a remote end using HTTP + JSON.\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar url = require('url');\n\nvar cmd = require('../lib/command');\n\nvar error = require('../lib/error');\n\nvar logging = require('../lib/logging');\n\nvar promise = require('../lib/promise');\n\nvar Session = require('../lib/session').Session;\n/**\n * Converts a headers map to a HTTP header block string.\n * @param {!Map<string, string>} headers The map to convert.\n * @return {string} The headers as a string.\n */\n\n\nfunction headersToString(headers) {\n  var ret = [];\n  headers.forEach(function (value, name) {\n    ret.push(\"\".concat(name.toLowerCase(), \": \").concat(value));\n  });\n  return ret.join('\\n');\n}\n/**\n * Represents a HTTP request message. This class is a \"partial\" request and only\n * defines the path on the server to send a request to. It is each client's\n * responsibility to build the full URL for the final request.\n * @final\n */\n\n\nvar HttpRequest = /*#__PURE__*/function () {\n  /**\n   * @param {string} method The HTTP method to use for the request.\n   * @param {string} path The path on the server to send the request to.\n   * @param {Object=} opt_data This request's non-serialized JSON payload data.\n   */\n  function HttpRequest(method, path, opt_data) {\n    _classCallCheck(this, HttpRequest);\n\n    this.method =\n    /** string */\n    method;\n    this.path =\n    /** string */\n    path;\n    this.data =\n    /** Object */\n    opt_data;\n    this.headers =\n    /** !Map<string, string> */\n    new Map([['Accept', 'application/json; charset=utf-8']]);\n  }\n  /** @override */\n\n\n  _createClass(HttpRequest, [{\n    key: \"toString\",\n    value: function toString() {\n      var ret = \"\".concat(this.method, \" \").concat(this.path, \" HTTP/1.1\\n\");\n      ret += headersToString(this.headers) + '\\n\\n';\n\n      if (this.data) {\n        ret += JSON.stringify(this.data);\n      }\n\n      return ret;\n    }\n  }]);\n\n  return HttpRequest;\n}();\n/**\n * Represents a HTTP response message.\n * @final\n */\n\n\nvar HttpResponse = /*#__PURE__*/function () {\n  /**\n   * @param {number} status The response code.\n   * @param {!Object<string>} headers The response headers. All header names\n   *     will be converted to lowercase strings for consistent lookups.\n   * @param {string} body The response body.\n   */\n  function HttpResponse(status, headers, body) {\n    _classCallCheck(this, HttpResponse);\n\n    this.status =\n    /** number */\n    status;\n    this.body =\n    /** string */\n    body;\n    this.headers =\n    /** !Map<string, string>*/\n    new Map();\n\n    for (var header in headers) {\n      this.headers.set(header.toLowerCase(), headers[header]);\n    }\n  }\n  /** @override */\n\n\n  _createClass(HttpResponse, [{\n    key: \"toString\",\n    value: function toString() {\n      var ret = \"HTTP/1.1 \".concat(this.status, \"\\n\").concat(headersToString(this.headers), \"\\n\\n\");\n\n      if (this.body) {\n        ret += this.body;\n      }\n\n      return ret;\n    }\n  }]);\n\n  return HttpResponse;\n}();\n\nfunction post(path) {\n  return resource('POST', path);\n}\n\nfunction del(path) {\n  return resource('DELETE', path);\n}\n\nfunction get(path) {\n  return resource('GET', path);\n}\n\nfunction resource(method, path) {\n  return {\n    method: method,\n    path: path\n  };\n}\n/** @const {!Map<string, {method: string, path: string}>} */\n\n\nvar COMMAND_MAP = new Map([[cmd.Name.GET_SERVER_STATUS, get('/status')], [cmd.Name.NEW_SESSION, post('/session')], [cmd.Name.GET_SESSIONS, get('/sessions')], [cmd.Name.DESCRIBE_SESSION, get('/session/:sessionId')], [cmd.Name.QUIT, del('/session/:sessionId')], [cmd.Name.CLOSE, del('/session/:sessionId/window')], [cmd.Name.GET_CURRENT_WINDOW_HANDLE, get('/session/:sessionId/window_handle')], [cmd.Name.GET_WINDOW_HANDLES, get('/session/:sessionId/window_handles')], [cmd.Name.GET_CURRENT_URL, get('/session/:sessionId/url')], [cmd.Name.GET, post('/session/:sessionId/url')], [cmd.Name.GO_BACK, post('/session/:sessionId/back')], [cmd.Name.GO_FORWARD, post('/session/:sessionId/forward')], [cmd.Name.REFRESH, post('/session/:sessionId/refresh')], [cmd.Name.ADD_COOKIE, post('/session/:sessionId/cookie')], [cmd.Name.GET_ALL_COOKIES, get('/session/:sessionId/cookie')], [cmd.Name.DELETE_ALL_COOKIES, del('/session/:sessionId/cookie')], [cmd.Name.DELETE_COOKIE, del('/session/:sessionId/cookie/:name')], [cmd.Name.FIND_ELEMENT, post('/session/:sessionId/element')], [cmd.Name.FIND_ELEMENTS, post('/session/:sessionId/elements')], [cmd.Name.GET_ACTIVE_ELEMENT, post('/session/:sessionId/element/active')], [cmd.Name.FIND_CHILD_ELEMENT, post('/session/:sessionId/element/:id/element')], [cmd.Name.FIND_CHILD_ELEMENTS, post('/session/:sessionId/element/:id/elements')], [cmd.Name.CLEAR_ELEMENT, post('/session/:sessionId/element/:id/clear')], [cmd.Name.CLICK_ELEMENT, post('/session/:sessionId/element/:id/click')], [cmd.Name.SEND_KEYS_TO_ELEMENT, post('/session/:sessionId/element/:id/value')], [cmd.Name.SUBMIT_ELEMENT, post('/session/:sessionId/element/:id/submit')], [cmd.Name.GET_ELEMENT_TEXT, get('/session/:sessionId/element/:id/text')], [cmd.Name.GET_ELEMENT_TAG_NAME, get('/session/:sessionId/element/:id/name')], [cmd.Name.IS_ELEMENT_SELECTED, get('/session/:sessionId/element/:id/selected')], [cmd.Name.IS_ELEMENT_ENABLED, get('/session/:sessionId/element/:id/enabled')], [cmd.Name.IS_ELEMENT_DISPLAYED, get('/session/:sessionId/element/:id/displayed')], [cmd.Name.GET_ELEMENT_LOCATION, get('/session/:sessionId/element/:id/location')], [cmd.Name.GET_ELEMENT_SIZE, get('/session/:sessionId/element/:id/size')], [cmd.Name.GET_ELEMENT_ATTRIBUTE, get('/session/:sessionId/element/:id/attribute/:name')], [cmd.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY, get('/session/:sessionId/element/:id/css/:propertyName')], [cmd.Name.ELEMENT_EQUALS, get('/session/:sessionId/element/:id/equals/:other')], [cmd.Name.TAKE_ELEMENT_SCREENSHOT, get('/session/:sessionId/element/:id/screenshot')], [cmd.Name.SWITCH_TO_WINDOW, post('/session/:sessionId/window')], [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/current/maximize')], [cmd.Name.GET_WINDOW_POSITION, get('/session/:sessionId/window/current/position')], [cmd.Name.SET_WINDOW_POSITION, post('/session/:sessionId/window/current/position')], [cmd.Name.GET_WINDOW_SIZE, get('/session/:sessionId/window/current/size')], [cmd.Name.SET_WINDOW_SIZE, post('/session/:sessionId/window/current/size')], [cmd.Name.SWITCH_TO_FRAME, post('/session/:sessionId/frame')], [cmd.Name.GET_PAGE_SOURCE, get('/session/:sessionId/source')], [cmd.Name.GET_TITLE, get('/session/:sessionId/title')], [cmd.Name.EXECUTE_SCRIPT, post('/session/:sessionId/execute')], [cmd.Name.EXECUTE_ASYNC_SCRIPT, post('/session/:sessionId/execute_async')], [cmd.Name.SCREENSHOT, get('/session/:sessionId/screenshot')], [cmd.Name.SET_TIMEOUT, post('/session/:sessionId/timeouts')], [cmd.Name.SET_SCRIPT_TIMEOUT, post('/session/:sessionId/timeouts/async_script')], [cmd.Name.IMPLICITLY_WAIT, post('/session/:sessionId/timeouts/implicit_wait')], [cmd.Name.MOVE_TO, post('/session/:sessionId/moveto')], [cmd.Name.CLICK, post('/session/:sessionId/click')], [cmd.Name.DOUBLE_CLICK, post('/session/:sessionId/doubleclick')], [cmd.Name.MOUSE_DOWN, post('/session/:sessionId/buttondown')], [cmd.Name.MOUSE_UP, post('/session/:sessionId/buttonup')], [cmd.Name.MOVE_TO, post('/session/:sessionId/moveto')], [cmd.Name.SEND_KEYS_TO_ACTIVE_ELEMENT, post('/session/:sessionId/keys')], [cmd.Name.TOUCH_SINGLE_TAP, post('/session/:sessionId/touch/click')], [cmd.Name.TOUCH_DOUBLE_TAP, post('/session/:sessionId/touch/doubleclick')], [cmd.Name.TOUCH_DOWN, post('/session/:sessionId/touch/down')], [cmd.Name.TOUCH_UP, post('/session/:sessionId/touch/up')], [cmd.Name.TOUCH_MOVE, post('/session/:sessionId/touch/move')], [cmd.Name.TOUCH_SCROLL, post('/session/:sessionId/touch/scroll')], [cmd.Name.TOUCH_LONG_PRESS, post('/session/:sessionId/touch/longclick')], [cmd.Name.TOUCH_FLICK, post('/session/:sessionId/touch/flick')], [cmd.Name.ACCEPT_ALERT, post('/session/:sessionId/accept_alert')], [cmd.Name.DISMISS_ALERT, post('/session/:sessionId/dismiss_alert')], [cmd.Name.GET_ALERT_TEXT, get('/session/:sessionId/alert_text')], [cmd.Name.SET_ALERT_TEXT, post('/session/:sessionId/alert_text')], [cmd.Name.SET_ALERT_CREDENTIALS, post('/session/:sessionId/alert/credentials')], [cmd.Name.GET_LOG, post('/session/:sessionId/log')], [cmd.Name.GET_AVAILABLE_LOG_TYPES, get('/session/:sessionId/log/types')], [cmd.Name.GET_SESSION_LOGS, post('/logs')], [cmd.Name.UPLOAD_FILE, post('/session/:sessionId/file')]]);\n/** @const {!Map<string, {method: string, path: string}>} */\n\nvar W3C_COMMAND_MAP = new Map([[cmd.Name.GET_WINDOW_SIZE, get('/session/:sessionId/window/size')], [cmd.Name.SET_WINDOW_SIZE, post('/session/:sessionId/window/size')], [cmd.Name.MAXIMIZE_WINDOW, post('/session/:sessionId/window/maximize')]]);\n/**\n * A basic HTTP client used to send messages to a remote end.\n */\n\nvar HttpClient = /*#__PURE__*/function () {\n  /**\n   * @param {string} serverUrl URL for the WebDriver server to send commands to.\n   * @param {http.Agent=} opt_agent The agent to use for each request.\n   *     Defaults to `http.globalAgent`.\n   * @param {?string=} opt_proxy The proxy to use for the connection to the\n   *     server. Default is to use no proxy.\n   */\n  function HttpClient(serverUrl, opt_agent, opt_proxy) {\n    _classCallCheck(this, HttpClient);\n\n    var parsedUrl = url.parse(serverUrl);\n\n    if (!parsedUrl.hostname) {\n      throw new Error('Invalid server URL: ' + serverUrl);\n    }\n    /** @private {http.Agent} */\n\n\n    this.agent_ = opt_agent || null;\n    /** @private {?string} */\n\n    this.proxy_ = opt_proxy || null;\n    /**\n     * Base options for each request.\n     * @private {{auth: (?string|undefined),\n     *            host: string,\n     *            path: (?string|undefined),\n     *            port: (?string|undefined),\n     *            protocol: (?string|undefined)}}\n     */\n\n    this.options_ = {\n      auth: parsedUrl.auth,\n      host: parsedUrl.hostname,\n      path: parsedUrl.pathname,\n      port: parsedUrl.port,\n      protocol: parsedUrl.protocol\n    };\n  }\n  /**\n   * Sends a request to the server. The client will automatically follow any\n   * redirects returned by the server, fulfilling the returned promise with the\n   * final response.\n   *\n   * @param {!HttpRequest} httpRequest The request to send.\n   * @return {!promise.Promise<HttpResponse>} A promise that will be fulfilled\n   *     with the server's response.\n   */\n\n\n  _createClass(HttpClient, [{\n    key: \"send\",\n    value: function send(httpRequest) {\n      var data;\n      var headers = {};\n      httpRequest.headers.forEach(function (value, name) {\n        headers[name] = value;\n      });\n      headers['Content-Length'] = 0;\n\n      if (httpRequest.method == 'POST' || httpRequest.method == 'PUT') {\n        data = JSON.stringify(httpRequest.data);\n        headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        headers['Content-Type'] = 'application/json;charset=UTF-8';\n      }\n\n      var path = this.options_.path;\n\n      if (path[path.length - 1] === '/' && httpRequest.path[0] === '/') {\n        path += httpRequest.path.substring(1);\n      } else {\n        path += httpRequest.path;\n      }\n\n      var options = {\n        method: httpRequest.method,\n        auth: this.options_.auth,\n        host: this.options_.host,\n        port: this.options_.port,\n        protocol: this.options_.protocol,\n        path: path,\n        headers: headers\n      };\n\n      if (this.agent_) {\n        options.agent = this.agent_;\n      }\n\n      var proxy = this.proxy_;\n      return new promise.Promise(function (fulfill, reject) {\n        sendRequest(options, fulfill, reject, data, proxy);\n      });\n    }\n  }]);\n\n  return HttpClient;\n}();\n/**\n * Sends a single HTTP request.\n * @param {!Object} options The request options.\n * @param {function(!HttpResponse)} onOk The function to call if the\n *     request succeeds.\n * @param {function(!Error)} onError The function to call if the request fails.\n * @param {?string=} opt_data The data to send with the request.\n * @param {?string=} opt_proxy The proxy server to use for the request.\n */\n\n\nfunction sendRequest(options, onOk, onError, opt_data, opt_proxy) {\n  var host = options.host;\n  var port = options.port;\n\n  if (opt_proxy) {\n    var proxy = url.parse(opt_proxy);\n    options.headers['Host'] = options.host;\n    options.host = proxy.hostname;\n    options.port = proxy.port;\n\n    if (proxy.auth) {\n      options.headers['Proxy-Authorization'] = 'Basic ' + new Buffer(proxy.auth).toString('base64');\n    }\n  }\n\n  var requestFn = options.protocol === 'https:' ? https.request : http.request;\n  var request = requestFn(options, function onResponse(response) {\n    if (response.statusCode == 302 || response.statusCode == 303) {\n      try {\n        var location = url.parse(response.headers['location']);\n      } catch (ex) {\n        onError(Error('Failed to parse \"Location\" header for server redirect: ' + ex.message + '\\nResponse was: \\n' + new HttpResponse(response.statusCode, response.headers, '')));\n        return;\n      }\n\n      if (!location.hostname) {\n        location.hostname = host;\n        location.port = port;\n      }\n\n      request.abort();\n      sendRequest({\n        method: 'GET',\n        host: location.hostname,\n        path: location.pathname + (location.search || ''),\n        port: location.port,\n        protocol: location.protocol,\n        headers: {\n          'Accept': 'application/json; charset=utf-8'\n        }\n      }, onOk, onError, undefined, opt_proxy);\n      return;\n    }\n\n    var body = [];\n    response.on('data', body.push.bind(body));\n    response.on('end', function () {\n      var resp = new HttpResponse(\n      /** @type {number} */\n      response.statusCode,\n      /** @type {!Object<string>} */\n      response.headers, body.join('').replace(/\\0/g, ''));\n      onOk(resp);\n    });\n  });\n  request.on('error', function (e) {\n    if (e.code === 'ECONNRESET') {\n      setTimeout(function () {\n        sendRequest(options, onOk, onError, opt_data, opt_proxy);\n      }, 15);\n    } else {\n      var message = e.message;\n\n      if (e.code) {\n        message = e.code + ' ' + message;\n      }\n\n      onError(new Error(message));\n    }\n  });\n\n  if (opt_data) {\n    request.write(opt_data);\n  }\n\n  request.end();\n}\n/**\n * A command executor that communicates with the server using HTTP + JSON.\n *\n * By default, each instance of this class will use the legacy wire protocol\n * from [Selenium project][json]. The executor will automatically switch to the\n * [W3C wire protocol][w3c] if the remote end returns a compliant response to\n * a new session command.\n *\n * [json]: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol\n * [w3c]: https://w3c.github.io/webdriver/webdriver-spec.html\n *\n * @implements {cmd.Executor}\n */\n\n\nvar Executor = /*#__PURE__*/function () {\n  /**\n   * @param {!HttpClient} client The client to use for sending requests to the\n   *     server.\n   */\n  function Executor(client) {\n    _classCallCheck(this, Executor);\n\n    /** @private {!HttpClient} */\n    this.client_ = client;\n    /**\n     * Whether this executor should use the W3C wire protocol. The executor\n     * will automatically switch if the remote end sends a compliant response\n     * to a new session command, however, this property may be directly set to\n     * `true` to force the executor into W3C mode.\n     * @type {boolean}\n     */\n\n    this.w3c = false;\n    /** @private {Map<string, {method: string, path: string}>} */\n\n    this.customCommands_ = null;\n    /** @private {!logging.Logger} */\n\n    this.log_ = logging.getLogger('webdriver.http.Executor');\n  }\n  /**\n   * Defines a new command for use with this executor. When a command is sent,\n   * the {@code path} will be preprocessed using the command's parameters; any\n   * path segments prefixed with \":\" will be replaced by the parameter of the\n   * same name. For example, given \"/person/:name\" and the parameters\n   * \"{name: 'Bob'}\", the final command path will be \"/person/Bob\".\n   *\n   * @param {string} name The command name.\n   * @param {string} method The HTTP method to use when sending this command.\n   * @param {string} path The path to send the command to, relative to\n   *     the WebDriver server's command root and of the form\n   *     \"/path/:variable/segment\".\n   */\n\n\n  _createClass(Executor, [{\n    key: \"defineCommand\",\n    value: function defineCommand(name, method, path) {\n      if (!this.customCommands_) {\n        this.customCommands_ = new Map();\n      }\n\n      this.customCommands_.set(name, {\n        method: method,\n        path: path\n      });\n    }\n    /** @override */\n\n  }, {\n    key: \"execute\",\n    value: function execute(command) {\n      var _this = this;\n\n      var resource = this.customCommands_ && this.customCommands_.get(command.getName()) || this.w3c && W3C_COMMAND_MAP.get(command.getName()) || COMMAND_MAP.get(command.getName());\n\n      if (!resource) {\n        throw new error.UnknownCommandError('Unrecognized command: ' + command.getName());\n      }\n\n      var parameters = command.getParameters();\n      var path = buildPath(resource.path, parameters);\n      var request = new HttpRequest(resource.method, path, parameters);\n      var log = this.log_;\n      log.finer(function () {\n        return '>>>\\n' + request;\n      });\n      return this.client_.send(request).then(function (response) {\n        log.finer(function () {\n          return '<<<\\n' + response;\n        });\n        var parsed = parseHttpResponse(\n        /** @type {!HttpResponse} */\n        response, _this.w3c);\n\n        if (command.getName() === cmd.Name.NEW_SESSION || command.getName() === cmd.Name.DESCRIBE_SESSION) {\n          if (!parsed || !parsed['sessionId']) {\n            throw new error.WebDriverError('Unable to parse new session response: ' + response.body);\n          } // The remote end is a W3C compliant server if there is no `status`\n          // field in the response. This is not appliable for the DESCRIBE_SESSION\n          // command, which is not defined in the W3C spec.\n\n\n          if (command.getName() === cmd.Name.NEW_SESSION) {\n            _this.w3c = _this.w3c || !('status' in parsed);\n          }\n\n          return new Session(parsed['sessionId'], parsed['value']);\n        }\n\n        if (parsed) {\n          var value = parsed['value'];\n          return typeof value === 'undefined' ? null : value;\n        }\n\n        return parsed;\n      });\n    }\n  }]);\n\n  return Executor;\n}();\n/**\n * @param {string} str .\n * @return {?} .\n */\n\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (ignored) {// Do nothing.\n  }\n}\n/**\n * Callback used to parse {@link HttpResponse} objects from a\n * {@link HttpClient}.\n * @param {!HttpResponse} httpResponse The HTTP response to parse.\n * @param {boolean} w3c Whether the response should be processed using the\n *     W3C wire protocol.\n * @return {{value: ?}} The parsed response.\n * @throws {WebDriverError} If the HTTP response is an error.\n */\n\n\nfunction parseHttpResponse(httpResponse, w3c) {\n  var parsed = tryParse(httpResponse.body);\n\n  if (parsed !== undefined) {\n    if (w3c) {\n      if (httpResponse.status > 399) {\n        error.throwDecodedError(parsed);\n      }\n\n      if (httpResponse.status < 200) {\n        // This should never happen, but throw the raw response so\n        // users report it.\n        throw new error.WebDriverError(\"Unexpected HTTP response:\\n\".concat(httpResponse));\n      }\n    } else {\n      error.checkLegacyResponse(parsed);\n    }\n\n    if (!parsed || typeof parsed !== 'object') {\n      parsed = {\n        value: parsed\n      };\n    }\n\n    return parsed;\n  }\n\n  var value = httpResponse.body.replace(/\\r\\n/g, '\\n'); // 404 represents an unknown command; anything else > 399 is a generic unknown\n  // error.\n\n  if (httpResponse.status == 404) {\n    throw new error.UnsupportedOperationError(value);\n  } else if (httpResponse.status >= 400) {\n    throw new error.WebDriverError(value);\n  }\n\n  return {\n    value: value || null\n  };\n}\n/**\n * Builds a fully qualified path using the given set of command parameters. Each\n * path segment prefixed with ':' will be replaced by the value of the\n * corresponding parameter. All parameters spliced into the path will be\n * removed from the parameter map.\n * @param {string} path The original resource path.\n * @param {!Object<*>} parameters The parameters object to splice into the path.\n * @return {string} The modified path.\n */\n\n\nfunction buildPath(path, parameters) {\n  var pathParameters = path.match(/\\/:(\\w+)\\b/g);\n\n  if (pathParameters) {\n    for (var i = 0; i < pathParameters.length; ++i) {\n      var key = pathParameters[i].substring(2); // Trim the /:\n\n      if (key in parameters) {\n        var value = parameters[key]; // TODO: move webdriver.WebElement.ELEMENT definition to a\n        // common file so we can reference it here without pulling in all of\n        // webdriver.WebElement's dependencies.\n\n        if (value && value['ELEMENT']) {\n          // When inserting a WebElement into the URL, only use its ID value,\n          // not the full JSON.\n          value = value['ELEMENT'];\n        }\n\n        path = path.replace(pathParameters[i], '/' + value);\n        delete parameters[key];\n      } else {\n        throw new error.InvalidArgumentError('Missing required parameter: ' + key);\n      }\n    }\n  }\n\n  return path;\n} // PUBLIC API\n\n\nexports.Executor = Executor;\nexports.HttpClient = HttpClient;\nexports.Request = HttpRequest;\nexports.Response = HttpResponse;\nexports.buildPath = buildPath; // Exported for testing.","map":null,"metadata":{},"sourceType":"script"}