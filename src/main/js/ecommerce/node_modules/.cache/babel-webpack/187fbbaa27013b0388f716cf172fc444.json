{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/** @fileoverview Utilities for working with Firefox extensions. */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _inherits = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar _wrapNativeSuper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/wrapNativeSuper\").default;\n\nvar AdmZip = require('adm-zip'),\n    fs = require('fs'),\n    path = require('path'),\n    xml = require('xml2js');\n\nvar promise = require('../lib/promise'),\n    checkedCall = promise.checkedNodeCall,\n    io = require('../io');\n/**\n * Thrown when there an add-on is malformed.\n */\n\n\nvar AddonFormatError = /*#__PURE__*/function (_Error) {\n  _inherits(AddonFormatError, _Error);\n\n  var _super = _createSuper(AddonFormatError);\n\n  /** @param {string} msg The error message. */\n  function AddonFormatError(msg) {\n    var _this;\n\n    _classCallCheck(this, AddonFormatError);\n\n    _this = _super.call(this, msg);\n    /** @override */\n\n    _this.name = _this.constructor.name;\n    return _this;\n  }\n\n  return AddonFormatError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Installs an extension to the given directory.\n * @param {string} extension Path to the extension to install, as either a xpi\n *     file or a directory.\n * @param {string} dir Path to the directory to install the extension in.\n * @return {!promise.Promise.<string>} A promise for the add-on ID once\n *     installed.\n */\n\n\nfunction install(extension, dir) {\n  return getDetails(extension).then(function (details) {\n    function returnId() {\n      return details.id;\n    }\n\n    var dst = path.join(dir, details.id);\n\n    if (extension.slice(-4) === '.xpi') {\n      if (!details.unpack) {\n        return io.copy(extension, dst + '.xpi').then(returnId);\n      } else {\n        return checkedCall(fs.readFile, extension).then(function (buff) {\n          // TODO: find an async library for inflating a zip archive.\n          new AdmZip(buff).extractAllTo(dst, true);\n        }).then(returnId);\n      }\n    } else {\n      return io.copyDir(extension, dst).then(returnId);\n    }\n  });\n}\n/**\n * Describes a Firefox add-on.\n * @typedef {{id: string, name: string, version: string, unpack: boolean}}\n */\n\n\nvar AddonDetails;\n/** @typedef {{$: !Object<string, string>}} */\n\nvar RdfRoot;\n/**\n * Extracts the details needed to install an add-on.\n * @param {string} addonPath Path to the extension directory.\n * @return {!promise.Promise.<!AddonDetails>} A promise for the add-on details.\n */\n\nfunction getDetails(addonPath) {\n  return readManifest(addonPath).then(function (doc) {\n    var em = getNamespaceId(doc, 'http://www.mozilla.org/2004/em-rdf#');\n    var rdf = getNamespaceId(doc, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');\n    var description = doc[rdf + 'RDF'][rdf + 'Description'][0];\n    var details = {\n      id: getNodeText(description, em + 'id'),\n      name: getNodeText(description, em + 'name'),\n      version: getNodeText(description, em + 'version'),\n      unpack: getNodeText(description, em + 'unpack') || false\n    };\n\n    if (typeof details.unpack === 'string') {\n      details.unpack = details.unpack.toLowerCase() === 'true';\n    }\n\n    if (!details.id) {\n      throw new AddonFormatError('Could not find add-on ID for ' + addonPath);\n    }\n\n    return details;\n  });\n\n  function getNodeText(node, name) {\n    return node[name] && node[name][0] || '';\n  }\n\n  function getNamespaceId(doc, url) {\n    var keys = Object.keys(doc);\n\n    if (keys.length !== 1) {\n      throw new AddonFormatError('Malformed manifest for add-on ' + addonPath);\n    }\n\n    var namespaces =\n    /** @type {!RdfRoot} */\n    doc[keys[0]].$;\n    var id = '';\n    Object.keys(namespaces).some(function (ns) {\n      if (namespaces[ns] !== url) {\n        return false;\n      }\n\n      if (ns.indexOf(':') != -1) {\n        id = ns.split(':')[1] + ':';\n      }\n\n      return true;\n    });\n    return id;\n  }\n}\n/**\n * Reads the manifest for a Firefox add-on.\n * @param {string} addonPath Path to a Firefox add-on as a xpi or an extension.\n * @return {!promise.Promise<!Object>} A promise for the parsed manifest.\n */\n\n\nfunction readManifest(addonPath) {\n  var manifest;\n\n  if (addonPath.slice(-4) === '.xpi') {\n    manifest = checkedCall(fs.readFile, addonPath).then(function (buff) {\n      var zip = new AdmZip(buff);\n\n      if (!zip.getEntry('install.rdf')) {\n        throw new AddonFormatError('Could not find install.rdf in ' + addonPath);\n      }\n\n      var done = promise.defer();\n      zip.readAsTextAsync('install.rdf', done.fulfill);\n      return done.promise;\n    });\n  } else {\n    manifest = checkedCall(fs.stat, addonPath).then(function (stats) {\n      if (!stats.isDirectory()) {\n        throw Error('Add-on path is niether a xpi nor a directory: ' + addonPath);\n      }\n\n      return checkedCall(fs.readFile, path.join(addonPath, 'install.rdf'));\n    });\n  }\n\n  return manifest.then(function (content) {\n    return checkedCall(xml.parseString, content);\n  });\n} // PUBLIC API\n\n\nexports.install = install;","map":null,"metadata":{},"sourceType":"script"}