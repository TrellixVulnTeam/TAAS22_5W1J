{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a {@linkplain Driver WebDriver} client for the Chrome\n * web browser. Before using this module, you must download the latest\n * [ChromeDriver release] and ensure it can be found on your system [PATH].\n *\n * There are three primary classes exported by this module:\n *\n * 1. {@linkplain ServiceBuilder}: configures the\n *     {@link selenium-webdriver/remote.DriverService remote.DriverService}\n *     that manages the [ChromeDriver] child process.\n *\n * 2. {@linkplain Options}: defines configuration options for each new Chrome\n *     session, such as which {@linkplain Options#setProxy proxy} to use,\n *     what {@linkplain Options#addExtensions extensions} to install, or\n *     what {@linkplain Options#addArguments command-line switches} to use when\n *     starting the browser.\n *\n * 3. {@linkplain Driver}: the WebDriver client; each new instance will control\n *     a unique browser session with a clean user profile (unless otherwise\n *     configured through the {@link Options} class).\n *\n * __Customizing the ChromeDriver Server__ <a id=\"custom-server\"></a>\n *\n * By default, every Chrome session will use a single driver service, which is\n * started the first time a {@link Driver} instance is created and terminated\n * when this process exits. The default service will inherit its environment\n * from the current process and direct all output to /dev/null. You may obtain\n * a handle to this default service using\n * {@link #getDefaultService getDefaultService()} and change its configuration\n * with {@link #setDefaultService setDefaultService()}.\n *\n * You may also create a {@link Driver} with its own driver service. This is\n * useful if you need to capture the server's log output for a specific session:\n *\n *     let chrome = require('selenium-webdriver/chrome');\n *\n *     let service = new chrome.ServiceBuilder()\n *         .loggingTo('/my/log/file.txt')\n *         .enableVerboseLogging()\n *         .build();\n *\n *     let options = new chrome.Options();\n *     // configure browser options ...\n *\n *     let driver = new chrome.Driver(options, service);\n *\n * Users should only instantiate the {@link Driver} class directly when they\n * need a custom driver service configuration (as shown above). For normal\n * operation, users should start Chrome using the\n * {@link selenium-webdriver.Builder}.\n *\n * __Working with Android__ <a id=\"android\"></a>\n *\n * The [ChromeDriver][android] supports running tests on the Chrome browser as\n * well as [WebView apps][webview] starting in Android 4.4 (KitKat). In order to\n * work with Android, you must first start the adb\n *\n *     adb start-server\n *\n * By default, adb will start on port 5037. You may change this port, but this\n * will require configuring a [custom server](#custom-server) that will connect\n * to adb on the {@linkplain ServiceBuilder#setAdbPort correct port}:\n *\n *     let service = new chrome.ServiceBuilder()\n *         .setAdbPort(1234)\n *         build();\n *     // etc.\n *\n * The ChromeDriver may be configured to launch Chrome on Android using\n * {@link Options#androidChrome()}:\n *\n *     let driver = new Builder()\n *         .forBrowser('chrome')\n *         .setChromeOptions(new chrome.Options().androidChrome())\n *         .build();\n *\n * Alternatively, you can configure the ChromeDriver to launch an app with a\n * Chrome-WebView by setting the {@linkplain Options#androidActivity\n * androidActivity} option:\n *\n *     let driver = new Builder()\n *         .forBrowser('chrome')\n *         .setChromeOptions(new chrome.Options()\n *             .androidPackage('com.example')\n *             .androidActivity('com.example.Activity'))\n *         .build();\n *\n * [Refer to the ChromeDriver site] for more information on using the\n * [ChromeDriver with Android][android].\n *\n * [ChromeDriver]: https://sites.google.com/a/chromium.org/chromedriver/\n * [ChromeDriver release]: http://chromedriver.storage.googleapis.com/index.html\n * [PATH]: http://en.wikipedia.org/wiki/PATH_%28variable%29\n * [android]: https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android\n * [webview]: https://developer.chrome.com/multidevice/webview/overview\n */\n'use strict';\n\nvar _inherits = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar fs = require('fs'),\n    util = require('util');\n\nvar executors = require('./executors'),\n    http = require('./http'),\n    io = require('./io'),\n    Capabilities = require('./lib/capabilities').Capabilities,\n    Capability = require('./lib/capabilities').Capability,\n    command = require('./lib/command'),\n    logging = require('./lib/logging'),\n    promise = require('./lib/promise'),\n    Symbols = require('./lib/symbols'),\n    webdriver = require('./lib/webdriver'),\n    portprober = require('./net/portprober'),\n    remote = require('./remote');\n/**\n * Name of the ChromeDriver executable.\n * @type {string}\n * @const\n */\n\n\nvar CHROMEDRIVER_EXE = process.platform === 'win32' ? 'chromedriver.exe' : 'chromedriver';\n/**\n * Custom command names supported by ChromeDriver.\n * @enum {string}\n */\n\nvar Command = {\n  LAUNCH_APP: 'launchApp'\n};\n/**\n * Creates a command executor with support for ChromeDriver's custom commands.\n * @param {!promise.Promise<string>} url The server's URL.\n * @return {!command.Executor} The new command executor.\n */\n\nfunction createExecutor(url) {\n  return new executors.DeferredExecutor(url.then(function (url) {\n    var client = new http.HttpClient(url);\n    var executor = new http.Executor(client);\n    executor.defineCommand(Command.LAUNCH_APP, 'POST', '/session/:sessionId/chromium/launch_app');\n    return executor;\n  }));\n}\n/**\n * Creates {@link selenium-webdriver/remote.DriverService} instances that manage\n * a [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/)\n * server in a child process.\n */\n\n\nvar ServiceBuilder = /*#__PURE__*/function () {\n  /**\n   * @param {string=} opt_exe Path to the server executable to use. If omitted,\n   *     the builder will attempt to locate the chromedriver on the current\n   *     PATH.\n   * @throws {Error} If provided executable does not exist, or the chromedriver\n   *     cannot be found on the PATH.\n   */\n  function ServiceBuilder(opt_exe) {\n    _classCallCheck(this, ServiceBuilder);\n\n    var exe = opt_exe || io.findInPath(CHROMEDRIVER_EXE, true);\n\n    if (!exe) {\n      throw Error('The ChromeDriver could not be found on the current PATH. Please ' + 'download the latest version of the ChromeDriver from ' + 'http://chromedriver.storage.googleapis.com/index.html and ensure ' + 'it can be found on your PATH.');\n    }\n\n    if (!fs.existsSync(exe)) {\n      throw Error('File does not exist: ' + exe);\n    }\n    /** @private {string} */\n\n\n    this.exe_ = exe;\n    /** @private {!Array<string>} */\n\n    this.args_ = [];\n    /**\n     * @private {(string|!Array<string|number|!stream.Stream|null|undefined>)}\n     */\n\n    this.stdio_ = 'ignore';\n    /** @private {?string} */\n\n    this.path_ = null;\n    /** @private {number} */\n\n    this.port_ = 0;\n    /** @private {Object<string, string>} */\n\n    this.env_ = null;\n  }\n  /**\n   * Sets the port to start the ChromeDriver on.\n   * @param {number} port The port to use, or 0 for any free port.\n   * @return {!ServiceBuilder} A self reference.\n   * @throws {Error} If the port is invalid.\n   */\n\n\n  _createClass(ServiceBuilder, [{\n    key: \"usingPort\",\n    value: function usingPort(port) {\n      if (port < 0) {\n        throw Error('port must be >= 0: ' + port);\n      }\n\n      this.port_ = port;\n      return this;\n    }\n    /**\n     * Sets which port adb is listening to. _The ChromeDriver will connect to adb\n     * if an {@linkplain Options#androidPackage Android session} is requested, but\n     * adb **must** be started beforehand._\n     *\n     * @param {number} port Which port adb is running on.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"setAdbPort\",\n    value: function setAdbPort(port) {\n      this.args_.push('--adb-port=' + port);\n      return this;\n    }\n    /**\n     * Sets the path of the log file the driver should log to. If a log file is\n     * not specified, the driver will log to stderr.\n     * @param {string} path Path of the log file to use.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"loggingTo\",\n    value: function loggingTo(path) {\n      this.args_.push('--log-path=' + path);\n      return this;\n    }\n    /**\n     * Enables verbose logging.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"enableVerboseLogging\",\n    value: function enableVerboseLogging() {\n      this.args_.push('--verbose');\n      return this;\n    }\n    /**\n     * Sets the number of threads the driver should use to manage HTTP requests.\n     * By default, the driver will use 4 threads.\n     * @param {number} n The number of threads to use.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"setNumHttpThreads\",\n    value: function setNumHttpThreads(n) {\n      this.args_.push('--http-threads=' + n);\n      return this;\n    }\n    /**\n     * Sets the base path for WebDriver REST commands (e.g. \"/wd/hub\").\n     * By default, the driver will accept commands relative to \"/\".\n     * @param {string} path The base path to use.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"setUrlBasePath\",\n    value: function setUrlBasePath(path) {\n      this.args_.push('--url-base=' + path);\n      this.path_ = path;\n      return this;\n    }\n    /**\n     * Defines the stdio configuration for the driver service. See\n     * {@code child_process.spawn} for more information.\n     * @param {(string|!Array<string|number|!stream.Stream|null|undefined>)}\n     *     config The configuration to use.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"setStdio\",\n    value: function setStdio(config) {\n      this.stdio_ = config;\n      return this;\n    }\n    /**\n     * Defines the environment to start the server under. This settings will be\n     * inherited by every browser session started by the server.\n     * @param {!Object<string, string>} env The environment to use.\n     * @return {!ServiceBuilder} A self reference.\n     */\n\n  }, {\n    key: \"withEnvironment\",\n    value: function withEnvironment(env) {\n      this.env_ = env;\n      return this;\n    }\n    /**\n     * Creates a new DriverService using this instance's current configuration.\n     * @return {!remote.DriverService} A new driver service using this instance's\n     *     current configuration.\n     * @throws {Error} If the driver exectuable was not specified and a default\n     *     could not be found on the current PATH.\n     */\n\n  }, {\n    key: \"build\",\n    value: function build() {\n      var port = this.port_ || portprober.findFreePort();\n      var args = this.args_.concat(); // Defensive copy.\n\n      return new remote.DriverService(this.exe_, {\n        loopback: true,\n        path: this.path_,\n        port: port,\n        args: promise.when(port, function (port) {\n          return args.concat('--port=' + port);\n        }),\n        env: this.env_,\n        stdio: this.stdio_\n      });\n    }\n  }]);\n\n  return ServiceBuilder;\n}();\n/** @type {remote.DriverService} */\n\n\nvar defaultService = null;\n/**\n * Sets the default service to use for new ChromeDriver instances.\n * @param {!remote.DriverService} service The service to use.\n * @throws {Error} If the default service is currently running.\n */\n\nfunction setDefaultService(service) {\n  if (defaultService && defaultService.isRunning()) {\n    throw Error('The previously configured ChromeDriver service is still running. ' + 'You must shut it down before you may adjust its configuration.');\n  }\n\n  defaultService = service;\n}\n/**\n * Returns the default ChromeDriver service. If such a service has not been\n * configured, one will be constructed using the default configuration for\n * a ChromeDriver executable found on the system PATH.\n * @return {!remote.DriverService} The default ChromeDriver service.\n */\n\n\nfunction getDefaultService() {\n  if (!defaultService) {\n    defaultService = new ServiceBuilder().build();\n  }\n\n  return defaultService;\n}\n/**\n * @type {string}\n * @const\n */\n\n\nvar OPTIONS_CAPABILITY_KEY = 'chromeOptions';\n/**\n * Class for managing ChromeDriver specific options.\n */\n\nvar Options = /*#__PURE__*/function (_Symbols$serialize) {\n  function Options() {\n    _classCallCheck(this, Options);\n\n    /** @private {!Object} */\n    this.options_ = {};\n    /** @private {!Array<(string|!Buffer)>} */\n\n    this.extensions_ = [];\n    /** @private {?logging.Preferences} */\n\n    this.logPrefs_ = null;\n    /** @private {?./lib/capabilities.ProxyConfig} */\n\n    this.proxy_ = null;\n  }\n  /**\n   * Extracts the ChromeDriver specific options from the given capabilities\n   * object.\n   * @param {!Capabilities} caps The capabilities object.\n   * @return {!Options} The ChromeDriver options.\n   */\n\n\n  _createClass(Options, [{\n    key: \"addArguments\",\n    value:\n    /**\n     * Add additional command line arguments to use when launching the Chrome\n     * browser.  Each argument may be specified with or without the \"--\" prefix\n     * (e.g. \"--foo\" and \"foo\"). Arguments with an associated value should be\n     * delimited by an \"=\": \"foo=bar\".\n     * @param {...(string|!Array<string>)} var_args The arguments to add.\n     * @return {!Options} A self reference.\n     */\n    function addArguments(var_args) {\n      var args = this.options_.args || [];\n      args = args.concat.apply(args, arguments);\n\n      if (args.length) {\n        this.options_.args = args;\n      }\n\n      return this;\n    }\n    /**\n     * List of Chrome command line switches to exclude that ChromeDriver by default\n     * passes when starting Chrome.  Do not prefix switches with \"--\".\n     *\n     * @param {...(string|!Array<string>)} var_args The switches to exclude.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"excludeSwitches\",\n    value: function excludeSwitches(var_args) {\n      var switches = this.options_.excludeSwitches || [];\n      switches = switches.concat.apply(switches, arguments);\n\n      if (switches.length) {\n        this.options_.excludeSwitches = switches;\n      }\n\n      return this;\n    }\n    /**\n     * Add additional extensions to install when launching Chrome. Each extension\n     * should be specified as the path to the packed CRX file, or a Buffer for an\n     * extension.\n     * @param {...(string|!Buffer|!Array<(string|!Buffer)>)} var_args The\n     *     extensions to add.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"addExtensions\",\n    value: function addExtensions(var_args) {\n      this.extensions_ = this.extensions_.concat.apply(this.extensions_, arguments);\n      return this;\n    }\n    /**\n     * Sets the path to the Chrome binary to use. On Mac OS X, this path should\n     * reference the actual Chrome executable, not just the application binary\n     * (e.g. \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\").\n     *\n     * The binary path be absolute or relative to the chromedriver server\n     * executable, but it must exist on the machine that will launch Chrome.\n     *\n     * @param {string} path The path to the Chrome binary to use.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setChromeBinaryPath\",\n    value: function setChromeBinaryPath(path) {\n      this.options_.binary = path;\n      return this;\n    }\n    /**\n     * Sets whether to leave the started Chrome browser running if the controlling\n     * ChromeDriver service is killed before {@link webdriver.WebDriver#quit()} is\n     * called.\n     * @param {boolean} detach Whether to leave the browser running if the\n     *     chromedriver service is killed before the session.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"detachDriver\",\n    value: function detachDriver(detach) {\n      this.options_.detach = detach;\n      return this;\n    }\n    /**\n     * Sets the user preferences for Chrome's user profile. See the \"Preferences\"\n     * file in Chrome's user data directory for examples.\n     * @param {!Object} prefs Dictionary of user preferences to use.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setUserPreferences\",\n    value: function setUserPreferences(prefs) {\n      this.options_.prefs = prefs;\n      return this;\n    }\n    /**\n     * Sets the logging preferences for the new session.\n     * @param {!logging.Preferences} prefs The logging preferences.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setLoggingPrefs\",\n    value: function setLoggingPrefs(prefs) {\n      this.logPrefs_ = prefs;\n      return this;\n    }\n    /**\n     * Sets the performance logging preferences. Options include:\n     *\n     * - `enableNetwork`: Whether or not to collect events from Network domain.\n     * - `enablePage`: Whether or not to collect events from Page domain.\n     * - `enableTimeline`: Whether or not to collect events from Timeline domain.\n     *     Note: when tracing is enabled, Timeline domain is implicitly disabled,\n     *     unless `enableTimeline` is explicitly set to true.\n     * - `tracingCategories`: A comma-separated string of Chrome tracing\n     *     categories for which trace events should be collected. An unspecified\n     *     or empty string disables tracing.\n     * - `bufferUsageReportingInterval`: The requested number of milliseconds\n     *     between DevTools trace buffer usage events. For example, if 1000, then\n     *     once per second, DevTools will report how full the trace buffer is. If\n     *     a report indicates the buffer usage is 100%, a warning will be issued.\n     *\n     * @param {{enableNetwork: boolean,\n     *          enablePage: boolean,\n     *          enableTimeline: boolean,\n     *          tracingCategories: string,\n     *          bufferUsageReportingInterval: number}} prefs The performance\n     *     logging preferences.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setPerfLoggingPrefs\",\n    value: function setPerfLoggingPrefs(prefs) {\n      this.options_.perfLoggingPrefs = prefs;\n      return this;\n    }\n    /**\n     * Sets preferences for the \"Local State\" file in Chrome's user data\n     * directory.\n     * @param {!Object} state Dictionary of local state preferences.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setLocalState\",\n    value: function setLocalState(state) {\n      this.options_.localState = state;\n      return this;\n    }\n    /**\n     * Sets the name of the activity hosting a Chrome-based Android WebView. This\n     * option must be set to connect to an [Android WebView](\n     * https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android)\n     *\n     * @param {string} name The activity name.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"androidActivity\",\n    value: function androidActivity(name) {\n      this.options_.androidActivity = name;\n      return this;\n    }\n    /**\n     * Sets the device serial number to connect to via ADB. If not specified, the\n     * ChromeDriver will select an unused device at random. An error will be\n     * returned if all devices already have active sessions.\n     *\n     * @param {string} serial The device serial number to connect to.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"androidDeviceSerial\",\n    value: function androidDeviceSerial(serial) {\n      this.options_.androidDeviceSerial = serial;\n      return this;\n    }\n    /**\n     * Configures the ChromeDriver to launch Chrome on Android via adb. This\n     * function is shorthand for\n     * {@link #androidPackage options.androidPackage('com.android.chrome')}.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"androidChrome\",\n    value: function androidChrome() {\n      return this.androidPackage('com.android.chrome');\n    }\n    /**\n     * Sets the package name of the Chrome or WebView app.\n     *\n     * @param {?string} pkg The package to connect to, or `null` to disable Android\n     *     and switch back to using desktop Chrome.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"androidPackage\",\n    value: function androidPackage(pkg) {\n      this.options_.androidPackage = pkg;\n      return this;\n    }\n    /**\n     * Sets the process name of the Activity hosting the WebView (as given by\n     * `ps`). If not specified, the process name is assumed to be the same as\n     * {@link #androidPackage}.\n     *\n     * @param {string} processName The main activity name.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"androidProcess\",\n    value: function androidProcess(processName) {\n      this.options_.androidProcess = processName;\n      return this;\n    }\n    /**\n     * Sets whether to connect to an already-running instead of the specified\n     * {@linkplain #androidProcess app} instead of launching the app with a clean\n     * data directory.\n     *\n     * @param {boolean} useRunning Whether to connect to a running instance.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"androidUseRunningApp\",\n    value: function androidUseRunningApp(useRunning) {\n      this.options_.androidUseRunningApp = useRunning;\n      return this;\n    }\n    /**\n     * Sets the path to Chrome's log file. This path should exist on the machine\n     * that will launch Chrome.\n     * @param {string} path Path to the log file to use.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setChromeLogFile\",\n    value: function setChromeLogFile(path) {\n      this.options_.logPath = path;\n      return this;\n    }\n    /**\n     * Sets the directory to store Chrome minidumps in. This option is only\n     * supported when ChromeDriver is running on Linux.\n     * @param {string} path The directory path.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setChromeMinidumpPath\",\n    value: function setChromeMinidumpPath(path) {\n      this.options_.minidumpPath = path;\n      return this;\n    }\n    /**\n     * Configures Chrome to emulate a mobile device. For more information, refer\n     * to the ChromeDriver project page on [mobile emulation][em]. Configuration\n     * options include:\n     *\n     * - `deviceName`: The name of a pre-configured [emulated device][devem]\n     * - `width`: screen width, in pixels\n     * - `height`: screen height, in pixels\n     * - `pixelRatio`: screen pixel ratio\n     *\n     * __Example 1: Using a Pre-configured Device__\n     *\n     *     let options = new chrome.Options().setMobileEmulation(\n     *         {deviceName: 'Google Nexus 5'});\n     *\n     *     let driver = new chrome.Driver(options);\n     *\n     * __Example 2: Using Custom Screen Configuration__\n     *\n     *     let options = new chrome.Options().setMobileEmulation({\n     *         width: 360,\n     *         height: 640,\n     *         pixelRatio: 3.0\n     *     });\n     *\n     *     let driver = new chrome.Driver(options);\n     *\n     *\n     * [em]: https://sites.google.com/a/chromium.org/chromedriver/mobile-emulation\n     * [devem]: https://developer.chrome.com/devtools/docs/device-mode\n     *\n     * @param {?({deviceName: string}|\n     *           {width: number, height: number, pixelRatio: number})} config The\n     *     mobile emulation configuration, or `null` to disable emulation.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setMobileEmulation\",\n    value: function setMobileEmulation(config) {\n      this.options_.mobileEmulation = config;\n      return this;\n    }\n    /**\n     * Sets the proxy settings for the new session.\n     * @param {./lib/capabilities.ProxyConfig} proxy The proxy configuration to\n     *    use.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setProxy\",\n    value: function setProxy(proxy) {\n      this.proxy_ = proxy;\n      return this;\n    }\n    /**\n     * Converts this options instance to a {@link Capabilities} object.\n     * @param {Capabilities=} opt_capabilities The capabilities to merge\n     *     these options into, if any.\n     * @return {!Capabilities} The capabilities.\n     */\n\n  }, {\n    key: \"toCapabilities\",\n    value: function toCapabilities(opt_capabilities) {\n      var caps = opt_capabilities || Capabilities.chrome();\n      caps.set(Capability.PROXY, this.proxy_).set(Capability.LOGGING_PREFS, this.logPrefs_).set(OPTIONS_CAPABILITY_KEY, this);\n      return caps;\n    }\n    /**\n     * Converts this instance to its JSON wire protocol representation. Note this\n     * function is an implementation not intended for general use.\n     * @return {!Object} The JSON wire protocol representation of this instance.\n     */\n\n  }, {\n    key: _Symbols$serialize,\n    value: function value() {\n      var json = {};\n\n      for (var key in this.options_) {\n        if (this.options_[key] != null) {\n          json[key] = this.options_[key];\n        }\n      }\n\n      if (this.extensions_.length) {\n        json.extensions = this.extensions_.map(function (extension) {\n          if (Buffer.isBuffer(extension)) {\n            return extension.toString('base64');\n          }\n\n          return promise.checkedNodeCall(fs.readFile, extension, 'base64');\n        });\n      }\n\n      return json;\n    }\n  }], [{\n    key: \"fromCapabilities\",\n    value: function fromCapabilities(caps) {\n      var options = new Options();\n      var o = caps.get(OPTIONS_CAPABILITY_KEY);\n\n      if (o instanceof Options) {\n        options = o;\n      } else if (o) {\n        options.addArguments(o.args || []).addExtensions(o.extensions || []).detachDriver(o.detach).excludeSwitches(o.excludeSwitches || []).setChromeBinaryPath(o.binary).setChromeLogFile(o.logPath).setChromeMinidumpPath(o.minidumpPath).setLocalState(o.localState).setMobileEmulation(o.mobileEmulation).setUserPreferences(o.prefs).setPerfLoggingPrefs(o.perfLoggingPrefs);\n      }\n\n      if (caps.has(Capability.PROXY)) {\n        options.setProxy(caps.get(Capability.PROXY));\n      }\n\n      if (caps.has(Capability.LOGGING_PREFS)) {\n        options.setLoggingPrefs(caps.get(Capability.LOGGING_PREFS));\n      }\n\n      return options;\n    }\n  }]);\n\n  return Options;\n}(Symbols.serialize);\n/**\n * Creates a new WebDriver client for Chrome.\n */\n\n\nvar Driver = /*#__PURE__*/function (_webdriver$WebDriver) {\n  _inherits(Driver, _webdriver$WebDriver);\n\n  var _super = _createSuper(Driver);\n\n  /**\n   * @param {(Capabilities|Options)=} opt_config The configuration\n   *     options.\n   * @param {remote.DriverService=} opt_service The session to use; will use\n   *     the {@linkplain #getDefaultService default service} by default.\n   * @param {promise.ControlFlow=} opt_flow The control flow to use,\n   *     or {@code null} to use the currently active flow.\n   */\n  function Driver(opt_config, opt_service, opt_flow) {\n    _classCallCheck(this, Driver);\n\n    var service = opt_service || getDefaultService();\n    var executor = createExecutor(service.start());\n    var caps = opt_config instanceof Options ? opt_config.toCapabilities() : opt_config || Capabilities.chrome();\n    var driver = webdriver.WebDriver.createSession(executor, caps, opt_flow);\n    return _super.call(this, driver.getSession(), executor, driver.controlFlow());\n  }\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n\n\n  _createClass(Driver, [{\n    key: \"setFileDetector\",\n    value: function setFileDetector() {}\n    /**\n     * Schedules a command to launch Chrome App with given ID.\n     * @param {string} id ID of the App to launch.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when app is launched.\n     */\n\n  }, {\n    key: \"launchApp\",\n    value: function launchApp(id) {\n      return this.schedule(new command.Command(Command.LAUNCH_APP).setParameter('id', id), 'Driver.launchApp()');\n    }\n  }]);\n\n  return Driver;\n}(webdriver.WebDriver); // PUBLIC API\n\n\nexports.Driver = Driver;\nexports.Options = Options;\nexports.ServiceBuilder = ServiceBuilder;\nexports.getDefaultService = getDefaultService;\nexports.setDefaultService = setDefaultService;","map":null,"metadata":{},"sourceType":"script"}