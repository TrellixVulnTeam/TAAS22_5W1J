{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines a WebDriver client for Safari. Before using this\n * module, you must install the\n * [latest version](http://selenium-release.storage.googleapis.com/index.html)\n * of the SafariDriver browser extension; using Safari for normal browsing is\n * not recommended once the extension has been installed. You can, and should,\n * disable the extension when the browser is not being used with WebDriver.\n */\n'use strict';\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _assertThisInitialized = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/assertThisInitialized\").default;\n\nvar _inherits = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar events = require('events');\n\nvar fs = require('fs');\n\nvar http = require('http');\n\nvar path = require('path');\n\nvar url = require('url');\n\nvar util = require('util');\n\nvar ws = require('ws');\n\nvar error = require('./error');\n\nvar io = require('./io');\n\nvar exec = require('./io/exec');\n\nvar isDevMode = require('./lib/devmode');\n\nvar Capabilities = require('./lib/capabilities').Capabilities;\n\nvar Capability = require('./lib/capabilities').Capability;\n\nvar command = require('./lib/command');\n\nvar promise = require('./lib/promise');\n\nvar Symbols = require('./lib/symbols');\n\nvar webdriver = require('./lib/webdriver');\n\nvar portprober = require('./net/portprober');\n/** @const */\n\n\nvar CLIENT_PATH = isDevMode ? path.join(__dirname, '../../../build/javascript/safari-driver/client.js') : path.join(__dirname, 'lib/safari/client.js');\n/** @const */\n\nvar LIBRARY_DIR = function () {\n  if (process.platform === 'darwin') {\n    return path.join('/Users', process.env['USER'], 'Library/Safari');\n  } else if (process.platform === 'win32') {\n    return path.join(process.env['APPDATA'], 'Apple Computer', 'Safari');\n  } else {\n    return '/dev/null';\n  }\n}();\n/** @const */\n\n\nvar SESSION_DATA_FILES = function () {\n  if (process.platform === 'darwin') {\n    var libraryDir = path.join('/Users', process.env['USER'], 'Library');\n    return [path.join(libraryDir, 'Caches/com.apple.Safari/Cache.db'), path.join(libraryDir, 'Cookies/Cookies.binarycookies'), path.join(libraryDir, 'Cookies/Cookies.plist'), path.join(libraryDir, 'Safari/History.plist'), path.join(libraryDir, 'Safari/LastSession.plist'), path.join(libraryDir, 'Safari/LocalStorage'), path.join(libraryDir, 'Safari/Databases')];\n  } else if (process.platform === 'win32') {\n    var appDataDir = path.join(process.env['APPDATA'], 'Apple Computer', 'Safari');\n    var localDataDir = path.join(process.env['LOCALAPPDATA'], 'Apple Computer', 'Safari');\n    return [path.join(appDataDir, 'History.plist'), path.join(appDataDir, 'LastSession.plist'), path.join(appDataDir, 'Cookies/Cookies.plist'), path.join(appDataDir, 'Cookies/Cookies.binarycookies'), path.join(localDataDir, 'Cache.db'), path.join(localDataDir, 'Databases'), path.join(localDataDir, 'LocalStorage')];\n  } else {\n    return [];\n  }\n}();\n/** @typedef {{port: number, address: string, family: string}} */\n\n\nvar Host;\n/**\n * A basic HTTP/WebSocket server used to communicate with the SafariDriver\n * browser extension.\n */\n\nvar Server = /*#__PURE__*/function (_events$EventEmitter) {\n  _inherits(Server, _events$EventEmitter);\n\n  var _super = _createSuper(Server);\n\n  function Server() {\n    var _this;\n\n    _classCallCheck(this, Server);\n\n    _this = _super.call(this);\n    var server = http.createServer(function (req, res) {\n      if (req.url === '/favicon.ico') {\n        res.writeHead(204);\n        res.end();\n        return;\n      }\n\n      var query = url.parse(\n      /** @type {string} */\n      req.url).query || '';\n\n      if (query.indexOf('url=') == -1) {\n        var address = server.address();\n        var host = address.address + ':' + address.port;\n        res.writeHead(302, {\n          'Location': 'http://' + host + '?url=ws://' + host\n        });\n        res.end();\n      }\n\n      fs.readFile(CLIENT_PATH, 'utf8', function (err, data) {\n        if (err) {\n          res.writeHead(500, {\n            'Content-Type': 'text/plain'\n          });\n          res.end(err.stack);\n          return;\n        }\n\n        var content = '<!DOCTYPE html><body><script>' + data + '</script>';\n        res.writeHead(200, {\n          'Content-Type': 'text/html; charset=utf-8',\n          'Content-Length': Buffer.byteLength(content, 'utf8')\n        });\n        res.end(content);\n      });\n    });\n    var wss = new ws.Server({\n      server: server\n    });\n    wss.on('connection', _this.emit.bind(_assertThisInitialized(_this), 'connection'));\n    /**\n     * Starts the server on a random port.\n     * @return {!promise.Promise<Host>} A promise that will resolve\n     *     with the server host when it has fully started.\n     */\n\n    _this.start = function () {\n      if (server.address()) {\n        return promise.fulfilled(server.address());\n      }\n\n      return portprober.findFreePort('localhost').then(function (port) {\n        return promise.checkedNodeCall(server.listen.bind(server, port, 'localhost'));\n      }).then(function () {\n        return server.address();\n      });\n    };\n    /**\n     * Stops the server.\n     * @return {!promise.Promise} A promise that will resolve when\n     *     the server has closed all connections.\n     */\n\n\n    _this.stop = function () {\n      return new promise.Promise(function (fulfill) {\n        server.close(fulfill);\n      });\n    };\n    /**\n     * @return {Host} This server's host info.\n     * @throws {Error} If the server is not running.\n     */\n\n\n    _this.address = function () {\n      var addr = server.address();\n\n      if (!addr) {\n        throw Error('There server is not running!');\n      }\n\n      return addr;\n    };\n\n    return _this;\n  }\n\n  return Server;\n}(events.EventEmitter);\n/**\n * @return {!Promise<string>} A promise that will resolve with the path\n *     to Safari on the current system.\n */\n\n\nfunction findSafariExecutable() {\n  switch (process.platform) {\n    case 'darwin':\n      return Promise.resolve('/Applications/Safari.app/Contents/MacOS/Safari');\n\n    case 'win32':\n      var files = [process.env['PROGRAMFILES'] || '\\\\Program Files', process.env['PROGRAMFILES(X86)'] || '\\\\Program Files (x86)'].map(function (prefix) {\n        return path.join(prefix, 'Safari\\\\Safari.exe');\n      });\n      return io.exists(files[0]).then(function (exists) {\n        return exists ? files[0] : io.exists(files[1]).then(function (exists) {\n          if (exists) {\n            return files[1];\n          }\n\n          throw Error('Unable to find Safari on the current system');\n        });\n      });\n\n    default:\n      return Promise.reject(Error('Safari is not supported on the current platform: ' + process.platform));\n  }\n}\n/**\n * @param {string} serverUrl The URL to connect to.\n * @return {!Promise<string>} A promise for the path to a file that Safari can\n *     open on start-up to trigger a new connection to the WebSocket server.\n */\n\n\nfunction createConnectFile(serverUrl) {\n  return io.tmpFile({\n    postfix: '.html'\n  }).then(function (f) {\n    var writeFile = promise.checkedNodeCall(fs.writeFile, f, '<!DOCTYPE html><script>window.location = \"' + serverUrl + '\";</script>', {\n      encoding: 'utf8'\n    });\n    return writeFile.then(function () {\n      return f;\n    });\n  });\n}\n/**\n * Deletes all session data files if so desired.\n * @param {!Object} desiredCapabilities .\n * @return {!Array<promise.Promise>} A list of promises for the deleted files.\n */\n\n\nfunction cleanSession(desiredCapabilities) {\n  if (!desiredCapabilities) {\n    return [];\n  }\n\n  var options = desiredCapabilities[OPTIONS_CAPABILITY_KEY];\n\n  if (!options) {\n    return [];\n  }\n\n  if (!options['cleanSession']) {\n    return [];\n  }\n\n  return SESSION_DATA_FILES.map(function (file) {\n    return io.unlink(file);\n  });\n}\n/** @return {string} . */\n\n\nfunction getRandomString() {\n  var seed = Date.now();\n  return Math.floor(Math.random() * seed).toString(36) + Math.abs(Math.floor(Math.random() * seed) ^ Date.now()).toString(36);\n}\n/**\n * @implements {command.Executor}\n */\n\n\nvar CommandExecutor = /*#__PURE__*/function () {\n  function CommandExecutor() {\n    _classCallCheck(this, CommandExecutor);\n\n    this.server_ = null;\n    /** @private {ws.WebSocket} */\n\n    this.socket_ = null;\n    /** @private {promise.Promise.<!exec.Command>} */\n\n    this.safari_ = null;\n  }\n  /** @override */\n\n\n  _createClass(CommandExecutor, [{\n    key: \"execute\",\n    value: function execute(cmd) {\n      var self = this;\n      return new promise.Promise(function (fulfill, reject) {\n        var safariCommand = JSON.stringify({\n          'origin': 'webdriver',\n          'type': 'command',\n          'command': {\n            'id': getRandomString(),\n            'name': cmd.getName(),\n            'parameters': cmd.getParameters()\n          }\n        });\n\n        switch (cmd.getName()) {\n          case command.Name.NEW_SESSION:\n            self.startSafari_(cmd).then(function () {\n              return self.sendCommand_(safariCommand);\n            }).then(fulfill, reject);\n            break;\n\n          case command.Name.QUIT:\n            self.destroySession_().then(function () {\n              return fulfill(null);\n            }, reject);\n            break;\n\n          default:\n            self.sendCommand_(safariCommand).then(fulfill, reject);\n            break;\n        }\n      });\n    }\n    /**\n     * @param {string} data .\n     * @return {!promise.Promise} .\n     * @private\n     */\n\n  }, {\n    key: \"sendCommand_\",\n    value: function sendCommand_(data) {\n      var self = this;\n      return new promise.Promise(function (fulfill, reject) {\n        // TODO: support reconnecting with the extension.\n        if (!self.socket_) {\n          self.destroySession_().thenFinally(function () {\n            reject(Error('The connection to the SafariDriver was closed'));\n          });\n          return;\n        }\n\n        self.socket_.send(data, function (err) {\n          if (err) {\n            reject(err);\n            return;\n          }\n        });\n        self.socket_.once('message', function (data) {\n          try {\n            data = JSON.parse(data);\n          } catch (ex) {\n            reject(Error('Failed to parse driver message: ' + data));\n            return;\n          }\n\n          try {\n            error.checkLegacyResponse(data['response']);\n            fulfill(data['response']['value']);\n          } catch (ex) {\n            reject(ex);\n          }\n        });\n      });\n    }\n    /**\n     * @param {!command.Command} command .\n     * @private\n     */\n\n  }, {\n    key: \"startSafari_\",\n    value: function startSafari_(command) {\n      this.server_ = new Server();\n      this.safari_ = this.server_.start().then(function (address) {\n        var tasks = cleanSession(\n        /** @type {!Object} */\n        command.getParameters()['desiredCapabilities']);\n        tasks.push(findSafariExecutable(), createConnectFile('http://' + address.address + ':' + address.port));\n        return promise.all(tasks).then(function (tasks) {\n          var exe = tasks[tasks.length - 2];\n          var html = tasks[tasks.length - 1];\n          return exec(exe, {\n            args: [html]\n          });\n        });\n      });\n      var connected = promise.defer();\n      var self = this;\n      var start = Date.now();\n      var timer = setTimeout(function () {\n        connected.reject(Error('Failed to connect to the SafariDriver after ' + (Date.now() - start) + ' ms; Have you installed the latest extension from ' + 'http://selenium-release.storage.googleapis.com/index.html?'));\n      }, 10 * 1000);\n      this.server_.once('connection', function (socket) {\n        clearTimeout(timer);\n        self.socket_ = socket;\n        socket.once('close', function () {\n          self.socket_ = null;\n        });\n        connected.fulfill();\n      });\n      return connected.promise;\n    }\n    /**\n     * Destroys the active session by stopping the WebSocket server and killing the\n     * Safari subprocess.\n     * @private\n     */\n\n  }, {\n    key: \"destroySession_\",\n    value: function destroySession_() {\n      var tasks = [];\n\n      if (this.server_) {\n        tasks.push(this.server_.stop());\n      }\n\n      if (this.safari_) {\n        tasks.push(this.safari_.then(function (safari) {\n          safari.kill();\n          return safari.result();\n        }));\n      }\n\n      var self = this;\n      return promise.all(tasks).finally(function () {\n        self.server_ = null;\n        self.socket_ = null;\n        self.safari_ = null;\n      });\n    }\n  }]);\n\n  return CommandExecutor;\n}();\n/** @const */\n\n\nvar OPTIONS_CAPABILITY_KEY = 'safari.options';\n/**\n * Configuration options specific to the {@link Driver SafariDriver}.\n */\n\nvar Options = /*#__PURE__*/function (_Symbols$serialize) {\n  function Options() {\n    _classCallCheck(this, Options);\n\n    /** @private {Object<string, *>} */\n    this.options_ = null;\n    /** @private {./lib/logging.Preferences} */\n\n    this.logPrefs_ = null;\n  }\n  /**\n   * Extracts the SafariDriver specific options from the given capabilities\n   * object.\n   * @param {!Capabilities} capabilities The capabilities object.\n   * @return {!Options} The ChromeDriver options.\n   */\n\n\n  _createClass(Options, [{\n    key: \"setCleanSession\",\n    value:\n    /**\n     * Sets whether to force Safari to start with a clean session. Enabling this\n     * option will cause all global browser data to be deleted.\n     * @param {boolean} clean Whether to make sure the session has no cookies,\n     *     cache entries, local storage, or databases.\n     * @return {!Options} A self reference.\n     */\n    function setCleanSession(clean) {\n      if (!this.options_) {\n        this.options_ = {};\n      }\n\n      this.options_['cleanSession'] = clean;\n      return this;\n    }\n    /**\n     * Sets the logging preferences for the new session.\n     * @param {!./lib/logging.Preferences} prefs The logging preferences.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setLoggingPrefs\",\n    value: function setLoggingPrefs(prefs) {\n      this.logPrefs_ = prefs;\n      return this;\n    }\n    /**\n     * Converts this options instance to a {@link Capabilities} object.\n     * @param {Capabilities=} opt_capabilities The capabilities to\n     *     merge these options into, if any.\n     * @return {!Capabilities} The capabilities.\n     */\n\n  }, {\n    key: \"toCapabilities\",\n    value: function toCapabilities(opt_capabilities) {\n      var caps = opt_capabilities || Capabilities.safari();\n\n      if (this.logPrefs_) {\n        caps.set(Capability.LOGGING_PREFS, this.logPrefs_);\n      }\n\n      if (this.options_) {\n        caps.set(OPTIONS_CAPABILITY_KEY, this);\n      }\n\n      return caps;\n    }\n    /**\n     * Converts this instance to its JSON wire protocol representation. Note this\n     * function is an implementation detail not intended for general use.\n     * @return {!Object<string, *>} The JSON wire protocol representation of this\n     *     instance.\n     */\n\n  }, {\n    key: _Symbols$serialize,\n    value: function value() {\n      return this.options_ || {};\n    }\n  }], [{\n    key: \"fromCapabilities\",\n    value: function fromCapabilities(capabilities) {\n      var options = new Options();\n      var o = capabilities.get(OPTIONS_CAPABILITY_KEY);\n\n      if (o instanceof Options) {\n        options = o;\n      } else if (o) {\n        options.setCleanSession(o.cleanSession);\n      }\n\n      if (capabilities.has(Capability.LOGGING_PREFS)) {\n        options.setLoggingPrefs(capabilities.get(Capability.LOGGING_PREFS));\n      }\n\n      return options;\n    }\n  }]);\n\n  return Options;\n}(Symbols.serialize);\n/**\n * A WebDriver client for Safari. This class should never be instantiated\n * directly; instead, use the {@linkplain ./builder.Builder Builder}:\n *\n *     var driver = new Builder()\n *         .forBrowser('safari')\n *         .build();\n *\n */\n\n\nvar Driver = /*#__PURE__*/function (_webdriver$WebDriver) {\n  _inherits(Driver, _webdriver$WebDriver);\n\n  var _super2 = _createSuper(Driver);\n\n  /**\n   * @param {(Options|Capabilities)=} opt_config The configuration\n   *     options for the new session.\n   * @param {promise.ControlFlow=} opt_flow The control flow to create\n   *     the driver under.\n   */\n  function Driver(opt_config, opt_flow) {\n    _classCallCheck(this, Driver);\n\n    var executor = new CommandExecutor();\n    var caps = opt_config instanceof Options ? opt_config.toCapabilities() : opt_config || Capabilities.safari();\n    var driver = webdriver.WebDriver.createSession(executor, caps, opt_flow);\n    return _super2.call(this, driver.getSession(), executor, driver.controlFlow());\n  }\n\n  return Driver;\n}(webdriver.WebDriver); // Public API\n\n\nexports.Driver = Driver;\nexports.Options = Options;","map":null,"metadata":{},"sourceType":"script"}