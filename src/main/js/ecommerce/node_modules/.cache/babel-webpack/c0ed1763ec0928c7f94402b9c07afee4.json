{"ast":null,"code":"var fs = require(\"fs\"),\n    pth = require(\"path\");\n\nfs.existsSync = fs.existsSync || pth.existsSync;\n\nvar ZipEntry = require(\"./zipEntry\"),\n    ZipFile = require(\"./zipFile\"),\n    Utils = require(\"./util\");\n\nmodule.exports = function (\n/*String*/\ninput) {\n  var _zip = undefined,\n      _filename = \"\";\n\n  if (input && typeof input === \"string\") {\n    // load zip file\n    if (fs.existsSync(input)) {\n      _filename = input;\n      _zip = new ZipFile(input, Utils.Constants.FILE);\n    } else {\n      throw Utils.Errors.INVALID_FILENAME;\n    }\n  } else if (input && Buffer.isBuffer(input)) {\n    // load buffer\n    _zip = new ZipFile(input, Utils.Constants.BUFFER);\n  } else {\n    // create new zip file\n    _zip = new ZipFile(null, Utils.Constants.NONE);\n  }\n\n  function _getEntry(\n  /*Object*/\n  entry) {\n    if (entry && _zip) {\n      var item; // If entry was given as a file name\n\n      if (typeof entry === \"string\") item = _zip.getEntry(entry); // if entry was given as a ZipEntry object\n\n      if (typeof entry === \"object\" && entry.entryName != undefined && entry.header != undefined) item = _zip.getEntry(entry.entryName);\n\n      if (item) {\n        return item;\n      }\n    }\n\n    return null;\n  }\n\n  return {\n    /**\r\n     * Extracts the given entry from the archive and returns the content as a Buffer object\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     *\r\n     * @return Buffer or Null in case of error\r\n     */\n    readFile: function readFile(\n    /*Object*/\n    entry) {\n      var item = _getEntry(entry);\n\n      return item && item.getData() || null;\n    },\n\n    /**\r\n     * Asynchronous readFile\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param callback\r\n     *\r\n     * @return Buffer or Null in case of error\r\n     */\n    readFileAsync: function readFileAsync(\n    /*Object*/\n    entry,\n    /*Function*/\n    callback) {\n      var item = _getEntry(entry);\n\n      if (item) {\n        item.getDataAsync(callback);\n      } else {\n        callback(null, \"getEntry failed for:\" + entry);\n      }\n    },\n\n    /**\r\n     * Extracts the given entry from the archive and returns the content as plain text in the given encoding\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param encoding Optional. If no encoding is specified utf8 is used\r\n     *\r\n     * @return String\r\n     */\n    readAsText: function readAsText(\n    /*Object*/\n    entry,\n    /*String - Optional*/\n    encoding) {\n      var item = _getEntry(entry);\n\n      if (item) {\n        var data = item.getData();\n\n        if (data && data.length) {\n          return data.toString(encoding || \"utf8\");\n        }\n      }\n\n      return \"\";\n    },\n\n    /**\r\n     * Asynchronous readAsText\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param callback\r\n     * @param encoding Optional. If no encoding is specified utf8 is used\r\n     *\r\n     * @return String\r\n     */\n    readAsTextAsync: function readAsTextAsync(\n    /*Object*/\n    entry,\n    /*Function*/\n    callback,\n    /*String - Optional*/\n    encoding) {\n      var item = _getEntry(entry);\n\n      if (item) {\n        item.getDataAsync(function (data) {\n          if (data && data.length) {\n            callback(data.toString(encoding || \"utf8\"));\n          } else {\n            callback(\"\");\n          }\n        });\n      } else {\n        callback(\"\");\n      }\n    },\n\n    /**\r\n     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\r\n     *\r\n     * @param entry\r\n     */\n    deleteFile: function deleteFile(\n    /*Object*/\n    entry) {\n      // @TODO: test deleteFile\n      var item = _getEntry(entry);\n\n      if (item) {\n        _zip.deleteEntry(item.entryName);\n      }\n    },\n\n    /**\r\n     * Adds a comment to the zip. The zip must be rewritten after adding the comment.\r\n     *\r\n     * @param comment\r\n     */\n    addZipComment: function addZipComment(\n    /*String*/\n    comment) {\n      // @TODO: test addZipComment\n      _zip.comment = comment;\n    },\n\n    /**\r\n     * Returns the zip comment\r\n     *\r\n     * @return String\r\n     */\n    getZipComment: function getZipComment() {\n      return _zip.comment || '';\n    },\n\n    /**\r\n     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\r\n     * The comment cannot exceed 65535 characters in length\r\n     *\r\n     * @param entry\r\n     * @param comment\r\n     */\n    addZipEntryComment: function addZipEntryComment(\n    /*Object*/\n    entry,\n    /*String*/\n    comment) {\n      var item = _getEntry(entry);\n\n      if (item) {\n        item.comment = comment;\n      }\n    },\n\n    /**\r\n     * Returns the comment of the specified entry\r\n     *\r\n     * @param entry\r\n     * @return String\r\n     */\n    getZipEntryComment: function getZipEntryComment(\n    /*Object*/\n    entry) {\n      var item = _getEntry(entry);\n\n      if (item) {\n        return item.comment || '';\n      }\n\n      return '';\n    },\n\n    /**\r\n     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\r\n     *\r\n     * @param entry\r\n     * @param content\r\n     */\n    updateFile: function updateFile(\n    /*Object*/\n    entry,\n    /*Buffer*/\n    content) {\n      var item = _getEntry(entry);\n\n      if (item) {\n        item.setData(content);\n      }\n    },\n\n    /**\r\n     * Adds a file from the disk to the archive\r\n     *\r\n     * @param localPath\r\n     */\n    addLocalFile: function addLocalFile(\n    /*String*/\n    localPath,\n    /*String*/\n    zipPath) {\n      if (fs.existsSync(localPath)) {\n        if (zipPath) {\n          zipPath = zipPath.split(\"\\\\\").join(\"/\");\n\n          if (zipPath.charAt(zipPath.length - 1) != \"/\") {\n            zipPath += \"/\";\n          }\n        } else {\n          zipPath = \"\";\n        }\n\n        var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n        this.addFile(zipPath + p, fs.readFileSync(localPath), \"\", 0);\n      } else {\n        throw Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\n      }\n    },\n\n    /**\r\n     * Adds a local directory and all its nested files and directories to the archive\r\n     *\r\n     * @param localPath\r\n     */\n    addLocalFolder: function addLocalFolder(\n    /*String*/\n    localPath,\n    /*String*/\n    zipPath) {\n      if (zipPath) {\n        zipPath = zipPath.split(\"\\\\\").join(\"/\");\n\n        if (zipPath.charAt(zipPath.length - 1) != \"/\") {\n          zipPath += \"/\";\n        }\n      } else {\n        zipPath = \"\";\n      }\n\n      localPath = localPath.split(\"\\\\\").join(\"/\"); //windows fix\n\n      if (localPath.charAt(localPath.length - 1) != \"/\") localPath += \"/\";\n\n      if (fs.existsSync(localPath)) {\n        var items = Utils.findFiles(localPath),\n            self = this;\n\n        if (items.length) {\n          items.forEach(function (path) {\n            var p = path.split(\"\\\\\").join(\"/\").replace(localPath, \"\"); //windows fix\n\n            if (p.charAt(p.length - 1) !== \"/\") {\n              self.addFile(zipPath + p, fs.readFileSync(path), \"\", 0);\n            } else {\n              self.addFile(zipPath + p, new Buffer(0), \"\", 0);\n            }\n          });\n        }\n      } else {\n        throw Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath);\n      }\n    },\n\n    /**\r\n     * Allows you to create a entry (file or directory) in the zip file.\r\n     * If you want to create a directory the entryName must end in / and a null buffer should be provided.\r\n     * Comment and attributes are optional\r\n     *\r\n     * @param entryName\r\n     * @param content\r\n     * @param comment\r\n     * @param attr\r\n     */\n    addFile: function addFile(\n    /*String*/\n    entryName,\n    /*Buffer*/\n    content,\n    /*String*/\n    comment,\n    /*Number*/\n    attr) {\n      var entry = new ZipEntry();\n      entry.entryName = entryName;\n      entry.comment = comment || \"\";\n      entry.attr = attr || 438; //0666;\n\n      if (entry.isDirectory && content.length) {// throw Utils.Errors.DIRECTORY_CONTENT_ERROR;\n      }\n\n      entry.setData(content);\n\n      _zip.setEntry(entry);\n    },\n\n    /**\r\n     * Returns an array of ZipEntry objects representing the files and folders inside the archive\r\n     *\r\n     * @return Array\r\n     */\n    getEntries: function getEntries() {\n      if (_zip) {\n        return _zip.entries;\n      } else {\n        return [];\n      }\n    },\n\n    /**\r\n     * Returns a ZipEntry object representing the file or folder specified by ``name``.\r\n     *\r\n     * @param name\r\n     * @return ZipEntry\r\n     */\n    getEntry: function getEntry(\n    /*String*/\n    name) {\n      return _getEntry(name);\n    },\n\n    /**\r\n     * Extracts the given entry to the given targetPath\r\n     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\r\n     *\r\n     * @param entry ZipEntry object or String with the full path of the entry\r\n     * @param targetPath Target folder where to write the file\r\n     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\r\n     *                          will be created in targetPath as well. Default is TRUE\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     *\r\n     * @return Boolean\r\n     */\n    extractEntryTo: function extractEntryTo(\n    /*Object*/\n    entry,\n    /*String*/\n    targetPath,\n    /*Boolean*/\n    maintainEntryPath,\n    /*Boolean*/\n    overwrite) {\n      overwrite = overwrite || false;\n      maintainEntryPath = typeof maintainEntryPath == \"undefined\" ? true : maintainEntryPath;\n\n      var item = _getEntry(entry);\n\n      if (!item) {\n        throw Utils.Errors.NO_ENTRY;\n      }\n\n      var target = pth.resolve(targetPath, maintainEntryPath ? item.entryName : pth.basename(item.entryName));\n\n      if (item.isDirectory) {\n        target = pth.resolve(target, \"..\");\n\n        var children = _zip.getEntryChildren(item);\n\n        children.forEach(function (child) {\n          if (child.isDirectory) return;\n          var content = child.getData();\n\n          if (!content) {\n            throw Utils.Errors.CANT_EXTRACT_FILE;\n          }\n\n          Utils.writeFileTo(pth.resolve(targetPath, maintainEntryPath ? child.entryName : child.entryName.substr(item.entryName.length)), content, overwrite);\n        });\n        return true;\n      }\n\n      var content = item.getData();\n      if (!content) throw Utils.Errors.CANT_EXTRACT_FILE;\n\n      if (fs.existsSync(targetPath) && !overwrite) {\n        throw Utils.Errors.CANT_OVERRIDE;\n      }\n\n      Utils.writeFileTo(target, content, overwrite);\n      return true;\n    },\n\n    /**\r\n     * Extracts the entire archive to the given location\r\n     *\r\n     * @param targetPath Target location\r\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\r\n     *                  Default is FALSE\r\n     */\n    extractAllTo: function extractAllTo(\n    /*String*/\n    targetPath,\n    /*Boolean*/\n    overwrite) {\n      overwrite = overwrite || false;\n\n      if (!_zip) {\n        throw Utils.Errors.NO_ZIP;\n      }\n\n      _zip.entries.forEach(function (entry) {\n        if (entry.isDirectory) {\n          Utils.makeDir(pth.resolve(targetPath, entry.entryName.toString()));\n          return;\n        }\n\n        var content = entry.getData();\n\n        if (!content) {\n          throw Utils.Errors.CANT_EXTRACT_FILE + \"2\";\n        }\n\n        Utils.writeFileTo(pth.resolve(targetPath, entry.entryName.toString()), content, overwrite);\n      });\n    },\n\n    /**\r\n     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\r\n     *\r\n     * @param targetFileName\r\n     * @param callback\r\n     */\n    writeZip: function writeZip(\n    /*String*/\n    targetFileName,\n    /*Function*/\n    callback) {\n      if (arguments.length == 1) {\n        if (typeof targetFileName == \"function\") {\n          callback = targetFileName;\n          targetFileName = \"\";\n        }\n      }\n\n      if (!targetFileName && _filename) {\n        targetFileName = _filename;\n      }\n\n      if (!targetFileName) return;\n\n      var zipData = _zip.compressToBuffer();\n\n      if (zipData) {\n        Utils.writeFileTo(targetFileName, zipData, true);\n      }\n    },\n\n    /**\r\n     * Returns the content of the entire zip file as a Buffer object\r\n     *\r\n     * @return Buffer\r\n     */\n    toBuffer: function toBuffer(\n    /*Function*/\n    onSuccess,\n    /*Function*/\n    onFail,\n    /*Function*/\n    onItemStart,\n    /*Function*/\n    onItemEnd) {\n      this.valueOf = 2;\n\n      if (typeof onSuccess == \"function\") {\n        _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n\n        return null;\n      }\n\n      return _zip.compressToBuffer();\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}