{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Profile management module. This module is considered internal;\n * users should use {@link selenium-webdriver/firefox}.\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar AdmZip = require('adm-zip'),\n    fs = require('fs'),\n    path = require('path'),\n    vm = require('vm');\n\nvar isDevMode = require('../lib/devmode'),\n    promise = require('../lib/promise'),\n    Symbols = require('../lib/symbols'),\n    io = require('../io'),\n    extension = require('./extension');\n/** @const */\n\n\nvar WEBDRIVER_PREFERENCES_PATH = isDevMode ? path.join(__dirname, '../../../firefox-driver/webdriver.json') : path.join(__dirname, '../lib/firefox/webdriver.json');\n/** @const */\n\nvar WEBDRIVER_EXTENSION_PATH = isDevMode ? path.join(__dirname, '../../../../build/javascript/firefox-driver/webdriver.xpi') : path.join(__dirname, '../lib/firefox/webdriver.xpi');\n/** @const */\n\nvar WEBDRIVER_EXTENSION_NAME = 'fxdriver@googlecode.com';\n/** @type {Object} */\n\nvar defaultPreferences = null;\n/**\n * Synchronously loads the default preferences used for the FirefoxDriver.\n * @return {!Object} The default preferences JSON object.\n */\n\nfunction getDefaultPreferences() {\n  if (!defaultPreferences) {\n    var contents =\n    /** @type {string} */\n    fs.readFileSync(WEBDRIVER_PREFERENCES_PATH, 'utf8');\n    defaultPreferences =\n    /** @type {!Object} */\n    JSON.parse(contents);\n  }\n\n  return defaultPreferences;\n}\n/**\n * Parses a user.js file in a Firefox profile directory.\n * @param {string} f Path to the file to parse.\n * @return {!promise.Promise<!Object>} A promise for the parsed preferences as\n *     a JSON object. If the file does not exist, an empty object will be\n *     returned.\n */\n\n\nfunction loadUserPrefs(f) {\n  var done = promise.defer();\n  fs.readFile(f, function (err, contents) {\n    if (err && err.code === 'ENOENT') {\n      done.fulfill({});\n      return;\n    }\n\n    if (err) {\n      done.reject(err);\n      return;\n    }\n\n    var prefs = {};\n    var context = vm.createContext({\n      'user_pref': function user_pref(key, value) {\n        prefs[key] = value;\n      }\n    });\n    vm.runInContext(\n    /** @type {string} */\n    contents, context, f);\n    done.fulfill(prefs);\n  });\n  return done.promise;\n}\n/**\n * @param {!Object} prefs The default preferences to write. Will be\n *     overridden by user.js preferences in the template directory and the\n *     frozen preferences required by WebDriver.\n * @param {string} dir Path to the directory write the file to.\n * @return {!promise.Promise<string>} A promise for the profile directory,\n *     to be fulfilled when user preferences have been written.\n */\n\n\nfunction writeUserPrefs(prefs, dir) {\n  var userPrefs = path.join(dir, 'user.js');\n  return loadUserPrefs(userPrefs).then(function (overrides) {\n    Object.assign(prefs, overrides);\n    Object.assign(prefs, getDefaultPreferences()['frozen']);\n    var contents = Object.keys(prefs).map(function (key) {\n      return 'user_pref(' + JSON.stringify(key) + ', ' + JSON.stringify(prefs[key]) + ');';\n    }).join('\\n');\n    var done = promise.defer();\n    fs.writeFile(userPrefs, contents, function (err) {\n      err && done.reject(err) || done.fulfill(dir);\n    });\n    return done.promise;\n  });\n}\n\n;\n/**\n * Installs a group of extensions in the given profile directory. If the\n * WebDriver extension is not included in this set, the default version\n * bundled with this package will be installed.\n * @param {!Array.<string>} extensions The extensions to install, as a\n *     path to an unpacked extension directory or a path to a xpi file.\n * @param {string} dir The profile directory to install to.\n * @param {boolean=} opt_excludeWebDriverExt Whether to skip installation of\n *     the default WebDriver extension.\n * @return {!Promise<string>} A promise for the main profile directory\n *     once all extensions have been installed.\n */\n\nfunction installExtensions(extensions, dir, opt_excludeWebDriverExt) {\n  var hasWebDriver = !!opt_excludeWebDriverExt;\n  var next = 0;\n  var extensionDir = path.join(dir, 'extensions');\n  return new Promise(function (fulfill, reject) {\n    io.exists(extensionDir).then(function (exists) {\n      if (!exists) {\n        return promise.checkedNodeCall(fs.mkdir, extensionDir);\n      }\n    }).then(installNext);\n\n    function installNext() {\n      if (next >= extensions.length) {\n        if (hasWebDriver) {\n          fulfill(dir);\n        } else {\n          install(WEBDRIVER_EXTENSION_PATH);\n        }\n      } else {\n        install(extensions[next++]);\n      }\n    }\n\n    function install(ext) {\n      extension.install(ext, extensionDir).then(function (id) {\n        hasWebDriver = hasWebDriver || id === WEBDRIVER_EXTENSION_NAME;\n        installNext();\n      }, reject);\n    }\n  });\n}\n/**\n * Decodes a base64 encoded profile.\n * @param {string} data The base64 encoded string.\n * @return {!Promise<string>} A promise for the path to the decoded profile\n *     directory.\n */\n\n\nfunction decode(data) {\n  return io.tmpFile().then(function (file) {\n    var buf = new Buffer(data, 'base64');\n    return promise.checkedNodeCall(fs.writeFile, file, buf).then(function () {\n      return io.tmpDir();\n    }).then(function (dir) {\n      var zip = new AdmZip(file);\n      zip.extractAllTo(dir); // Sync only? Why?? :-(\n\n      return dir;\n    });\n  });\n}\n/**\n * Models a Firefox profile directory for use with the FirefoxDriver. The\n * {@code Profile} directory uses an in-memory model until {@link #writeToDisk}\n * is called.\n */\n\n\nvar Profile = /*#__PURE__*/function (_Symbols$serialize) {\n  /**\n   * @param {string=} opt_dir Path to an existing Firefox profile directory to\n   *     use a template for this profile. If not specified, a blank profile will\n   *     be used.\n   */\n  function Profile(opt_dir) {\n    _classCallCheck(this, Profile);\n\n    /** @private {!Object} */\n    this.preferences_ = {};\n    Object.assign(this.preferences_, getDefaultPreferences()['mutable']);\n    Object.assign(this.preferences_, getDefaultPreferences()['frozen']);\n    /** @private {boolean} */\n\n    this.nativeEventsEnabled_ = true;\n    /** @private {(string|undefined)} */\n\n    this.template_ = opt_dir;\n    /** @private {number} */\n\n    this.port_ = 0;\n    /** @private {!Array<string>} */\n\n    this.extensions_ = [];\n  }\n  /**\n   * Registers an extension to be included with this profile.\n   * @param {string} extension Path to the extension to include, as either an\n   *     unpacked extension directory or the path to a xpi file.\n   */\n\n\n  _createClass(Profile, [{\n    key: \"addExtension\",\n    value: function addExtension(extension) {\n      this.extensions_.push(extension);\n    }\n    /**\n     * Sets a desired preference for this profile.\n     * @param {string} key The preference key.\n     * @param {(string|number|boolean)} value The preference value.\n     * @throws {Error} If attempting to set a frozen preference.\n     */\n\n  }, {\n    key: \"setPreference\",\n    value: function setPreference(key, value) {\n      var frozen = getDefaultPreferences()['frozen'];\n\n      if (frozen.hasOwnProperty(key) && frozen[key] !== value) {\n        throw Error('You may not set ' + key + '=' + JSON.stringify(value) + '; value is frozen for proper WebDriver functionality (' + key + '=' + JSON.stringify(frozen[key]) + ')');\n      }\n\n      this.preferences_[key] = value;\n    }\n    /**\n     * Returns the currently configured value of a profile preference. This does\n     * not include any defaults defined in the profile's template directory user.js\n     * file (if a template were specified on construction).\n     * @param {string} key The desired preference.\n     * @return {(string|number|boolean|undefined)} The current value of the\n     *     requested preference.\n     */\n\n  }, {\n    key: \"getPreference\",\n    value: function getPreference(key) {\n      return this.preferences_[key];\n    }\n    /**\n     * Specifies which host the driver should listen for commands on. If not\n     * specified, the driver will default to \"localhost\". This option should be\n     * specified when \"localhost\" is not mapped to the loopback address\n     * (127.0.0.1) in `/etc/hosts`.\n     *\n     * @param {string} host the host the driver should listen for commands on\n     */\n\n  }, {\n    key: \"setHost\",\n    value: function setHost(host) {\n      this.preferences_['webdriver_firefox_allowed_hosts'] = host;\n    }\n    /**\n     * @return {number} The port this profile is currently configured to use, or\n     *     0 if the port will be selected at random when the profile is written\n     *     to disk.\n     */\n\n  }, {\n    key: \"getPort\",\n    value: function getPort() {\n      return this.port_;\n    }\n    /**\n     * Sets the port to use for the WebDriver extension loaded by this profile.\n     * @param {number} port The desired port, or 0 to use any free port.\n     */\n\n  }, {\n    key: \"setPort\",\n    value: function setPort(port) {\n      this.port_ = port;\n    }\n    /**\n     * @return {boolean} Whether the FirefoxDriver is configured to automatically\n     *     accept untrusted SSL certificates.\n     */\n\n  }, {\n    key: \"acceptUntrustedCerts\",\n    value: function acceptUntrustedCerts() {\n      return !!this.preferences_['webdriver_accept_untrusted_certs'];\n    }\n    /**\n     * Sets whether the FirefoxDriver should automatically accept untrusted SSL\n     * certificates.\n     * @param {boolean} value .\n     */\n\n  }, {\n    key: \"setAcceptUntrustedCerts\",\n    value: function setAcceptUntrustedCerts(value) {\n      this.preferences_['webdriver_accept_untrusted_certs'] = !!value;\n    }\n    /**\n     * Sets whether to assume untrusted certificates come from untrusted issuers.\n     * @param {boolean} value .\n     */\n\n  }, {\n    key: \"setAssumeUntrustedCertIssuer\",\n    value: function setAssumeUntrustedCertIssuer(value) {\n      this.preferences_['webdriver_assume_untrusted_issuer'] = !!value;\n    }\n    /**\n     * @return {boolean} Whether to assume untrusted certs come from untrusted\n     *     issuers.\n     */\n\n  }, {\n    key: \"assumeUntrustedCertIssuer\",\n    value: function assumeUntrustedCertIssuer() {\n      return !!this.preferences_['webdriver_assume_untrusted_issuer'];\n    }\n    /**\n     * Sets whether to use native events with this profile.\n     * @param {boolean} enabled .\n     */\n\n  }, {\n    key: \"setNativeEventsEnabled\",\n    value: function setNativeEventsEnabled(enabled) {\n      this.nativeEventsEnabled_ = enabled;\n    }\n    /**\n     * Returns whether native events are enabled in this profile.\n     * @return {boolean} .\n     */\n\n  }, {\n    key: \"nativeEventsEnabled\",\n    value: function nativeEventsEnabled() {\n      return this.nativeEventsEnabled_;\n    }\n    /**\n     * Writes this profile to disk.\n     * @param {boolean=} opt_excludeWebDriverExt Whether to exclude the WebDriver\n     *     extension from the generated profile. Used to reduce the size of an\n     *     {@link #encode() encoded profile} since the server will always install\n     *     the extension itself.\n     * @return {!Promise<string>} A promise for the path to the new profile\n     *     directory.\n     */\n\n  }, {\n    key: \"writeToDisk\",\n    value: function writeToDisk(opt_excludeWebDriverExt) {\n      var profileDir = io.tmpDir();\n\n      if (this.template_) {\n        profileDir = profileDir.then(function (dir) {\n          return io.copyDir(\n          /** @type {string} */\n          this.template_, dir, /(parent\\.lock|lock|\\.parentlock)/);\n        }.bind(this));\n      } // Freeze preferences for async operations.\n\n\n      var prefs = {};\n      Object.assign(prefs, this.preferences_); // Freeze extensions for async operations.\n\n      var extensions = this.extensions_.concat();\n      return profileDir.then(function (dir) {\n        return writeUserPrefs(prefs, dir);\n      }).then(function (dir) {\n        return installExtensions(extensions, dir, !!opt_excludeWebDriverExt);\n      });\n    }\n    /**\n     * Encodes this profile as a zipped, base64 encoded directory.\n     * @return {!Promise<string>} A promise for the encoded profile.\n     */\n\n  }, {\n    key: \"encode\",\n    value: function encode() {\n      return this.writeToDisk(true).then(function (dir) {\n        var zip = new AdmZip();\n        zip.addLocalFolder(dir, ''); // Stored compression, see https://en.wikipedia.org/wiki/Zip_(file_format)\n\n        zip.getEntries()[0].header.method = 0;\n        return io.tmpFile().then(function (file) {\n          zip.writeZip(file); // Sync! Why oh why :-(\n\n          return promise.checkedNodeCall(fs.readFile, file);\n        });\n      }).then(function (data) {\n        return new Buffer(data).toString('base64');\n      });\n    }\n    /**\n     * Encodes this profile as a zipped, base64 encoded directory.\n     * @return {!Promise<string>} A promise for the encoded profile.\n     */\n\n  }, {\n    key: _Symbols$serialize,\n    value: function value() {\n      return this.encode();\n    }\n  }]);\n\n  return Profile;\n}(Symbols.serialize); // PUBLIC API\n\n\nexports.Profile = Profile;\nexports.decode = decode;\nexports.loadUserPrefs = loadUserPrefs;","map":null,"metadata":{},"sourceType":"script"}