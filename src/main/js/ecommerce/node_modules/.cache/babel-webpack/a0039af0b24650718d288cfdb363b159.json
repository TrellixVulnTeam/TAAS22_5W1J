{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar childProcess = require('child_process');\n\nvar promise = require('../lib/promise');\n/**\n * A hash with configuration options for an executed command.\n *\n * - `args` - Command line arguments.\n * - `env` - Command environment; will inherit from the current process if\n *     missing.\n * - `stdio` - IO configuration for the spawned server process. For more\n *     information, refer to the documentation of `child_process.spawn`.\n *\n * @typedef {{\n *   args: (!Array<string>|undefined),\n *   env: (!Object<string, string>|undefined),\n *   stdio: (string|!Array<string|number|!stream.Stream|null|undefined>|\n *           undefined)\n * }}\n */\n\n\nvar Options;\n/**\n * Describes a command's termination conditions.\n */\n\nvar Result = /*#__PURE__*/function () {\n  /**\n   * @param {?number} code The exit code, or {@code null} if the command did not\n   *     exit normally.\n   * @param {?string} signal The signal used to kill the command, or\n   *     {@code null}.\n   */\n  function Result(code, signal) {\n    _classCallCheck(this, Result);\n\n    /** @type {?number} */\n    this.code = code;\n    /** @type {?string} */\n\n    this.signal = signal;\n  }\n  /** @override */\n\n\n  _createClass(Result, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"Result(code=\".concat(this.code, \", signal=\").concat(this.signal, \")\");\n    }\n  }]);\n\n  return Result;\n}();\n\nvar COMMAND_RESULT =\n/** !WeakMap<!Command, !promise.Promise<!Result>> */\nnew WeakMap();\nvar KILL_HOOK =\n/** !WeakMap<!Command, function(string)> */\nnew WeakMap();\n/**\n * Represents a command running in a sub-process.\n */\n\nvar Command = /*#__PURE__*/function () {\n  /**\n   * @param {!promise.Promise<!Result>} result The command result.\n   * @param {function(string)} onKill The function to call when {@link #kill()}\n   *     is called.\n   */\n  function Command(result, onKill) {\n    _classCallCheck(this, Command);\n\n    COMMAND_RESULT.set(this, result);\n    KILL_HOOK.set(this, onKill);\n  }\n  /** @return {boolean} Whether this command is still running. */\n\n\n  _createClass(Command, [{\n    key: \"isRunning\",\n    value: function isRunning() {\n      return COMMAND_RESULT.get(this).isPending();\n    }\n    /**\n     * @return {!promise.Promise<!Result>} A promise for the result of this\n     *     command.\n     */\n\n  }, {\n    key: \"result\",\n    value: function result() {\n      return (\n        /** @type {!promise.Promise<!Result>} */\n        COMMAND_RESULT.get(this)\n      );\n    }\n    /**\n     * Sends a signal to the underlying process.\n     * @param {string=} opt_signal The signal to send; defaults to `SIGTERM`.\n     */\n\n  }, {\n    key: \"kill\",\n    value: function kill(opt_signal) {\n      KILL_HOOK.get(this)(opt_signal || 'SIGTERM');\n    }\n  }]);\n\n  return Command;\n}(); // PUBLIC API\n\n/**\n * Spawns a child process. The returned {@link Command} may be used to wait\n * for the process result or to send signals to the process.\n *\n * @param {string} command The executable to spawn.\n * @param {Options=} opt_options The command options.\n * @return {!Command} The launched command.\n */\n\n\nmodule.exports = function exec(command, opt_options) {\n  var options = opt_options || {};\n  var proc = childProcess.spawn(command, options.args || [], {\n    env: options.env || process.env,\n    stdio: options.stdio || 'ignore'\n  }).once('exit', onExit); // This process should not wait on the spawned child, however, we do\n  // want to ensure the child is killed when this process exits.\n\n  proc.unref();\n  process.once('exit', killCommand);\n  var result = promise.defer();\n  var cmd = new Command(result.promise, function (signal) {\n    if (!result.isPending() || !proc) {\n      return; // No longer running.\n    }\n\n    proc.kill(signal);\n  });\n  return cmd;\n\n  function onExit(code, signal) {\n    proc = null;\n    process.removeListener('exit', killCommand);\n    result.fulfill(new Result(code, signal));\n  }\n\n  function killCommand() {\n    process.removeListener('exit', killCommand);\n    proc && proc.kill('SIGTERM');\n  }\n}; // Exported to improve generated API documentation.\n\n\nmodule.exports.Command = Command;\n/** @typedef {!Options} */\n\nmodule.exports.Options = Options;\nmodule.exports.Result = Result;","map":null,"metadata":{},"sourceType":"script"}