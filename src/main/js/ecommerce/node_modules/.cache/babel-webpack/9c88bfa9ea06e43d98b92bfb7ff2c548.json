{"ast":null,"code":"var Utils = require(\"../util\"),\n    Constants = Utils.Constants;\n/* The central directory file header */\n\n\nmodule.exports = function () {\n  var _verMade = 0x0A,\n      _version = 0x0A,\n      _flags = 0,\n      _method = 0,\n      _time = 0,\n      _crc = 0,\n      _compressedSize = 0,\n      _size = 0,\n      _fnameLen = 0,\n      _extraLen = 0,\n      _comLen = 0,\n      _diskStart = 0,\n      _inattr = 0,\n      _attr = 0,\n      _offset = 0;\n  var _dataHeader = {};\n\n  function setTime(val) {\n    var val = new Date(val);\n    _time = (val.getFullYear() - 1980 & 0x7f) << 25 // b09-16 years from 1980\n    | val.getMonth() + 1 << 21 // b05-08 month\n    | val.getDay() << 16 // b00-04 hour\n    // 2 bytes time\n    | val.getHours() << 11 // b11-15 hour\n    | val.getMinutes() << 5 // b05-10 minute\n    | val.getSeconds() >> 1; // b00-04 seconds divided by 2\n  }\n\n  setTime(+new Date());\n  return {\n    get made() {\n      return _verMade;\n    },\n\n    set made(val) {\n      _verMade = val;\n    },\n\n    get version() {\n      return _version;\n    },\n\n    set version(val) {\n      _version = val;\n    },\n\n    get flags() {\n      return _flags;\n    },\n\n    set flags(val) {\n      _flags = val;\n    },\n\n    get method() {\n      return _method;\n    },\n\n    set method(val) {\n      _method = val;\n    },\n\n    get time() {\n      return new Date((_time >> 25 & 0x7f) + 1980, (_time >> 21 & 0x0f) - 1, _time >> 16 & 0x1f, _time >> 11 & 0x1f, _time >> 5 & 0x3f, (_time & 0x1f) << 1);\n    },\n\n    set time(val) {\n      setTime(val);\n    },\n\n    get crc() {\n      return _crc;\n    },\n\n    set crc(val) {\n      _crc = val;\n    },\n\n    get compressedSize() {\n      return _compressedSize;\n    },\n\n    set compressedSize(val) {\n      _compressedSize = val;\n    },\n\n    get size() {\n      return _size;\n    },\n\n    set size(val) {\n      _size = val;\n    },\n\n    get fileNameLength() {\n      return _fnameLen;\n    },\n\n    set fileNameLength(val) {\n      _fnameLen = val;\n    },\n\n    get extraLength() {\n      return _extraLen;\n    },\n\n    set extraLength(val) {\n      _extraLen = val;\n    },\n\n    get commentLength() {\n      return _comLen;\n    },\n\n    set commentLength(val) {\n      _comLen = val;\n    },\n\n    get diskNumStart() {\n      return _diskStart;\n    },\n\n    set diskNumStart(val) {\n      _diskStart = val;\n    },\n\n    get inAttr() {\n      return _inattr;\n    },\n\n    set inAttr(val) {\n      _inattr = val;\n    },\n\n    get attr() {\n      return _attr;\n    },\n\n    set attr(val) {\n      _attr = val;\n    },\n\n    get offset() {\n      return _offset;\n    },\n\n    set offset(val) {\n      _offset = val;\n    },\n\n    get encripted() {\n      return (_flags & 1) == 1;\n    },\n\n    get entryHeaderSize() {\n      return Constants.CENHDR + _fnameLen + _extraLen + _comLen;\n    },\n\n    get realDataOffset() {\n      return _offset + Constants.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;\n    },\n\n    get dataHeader() {\n      return _dataHeader;\n    },\n\n    loadDataHeaderFromBinary: function loadDataHeaderFromBinary(\n    /*Buffer*/\n    input) {\n      var data = input.slice(_offset, _offset + Constants.LOCHDR); // 30 bytes and should start with \"PK\\003\\004\"\n\n      if (data.readUInt32LE(0) != Constants.LOCSIG) {\n        throw Utils.Errors.INVALID_LOC;\n      }\n\n      _dataHeader = {\n        // version needed to extract\n        version: data.readUInt16LE(Constants.LOCVER),\n        // general purpose bit flag\n        flags: data.readUInt16LE(Constants.LOCFLG),\n        // compression method\n        method: data.readUInt16LE(Constants.LOCHOW),\n        // modification time (2 bytes time, 2 bytes date)\n        time: data.readUInt32LE(Constants.LOCTIM),\n        // uncompressed file crc-32 value\n        crc: data.readUInt32LE(Constants.LOCCRC),\n        // compressed size\n        compressedSize: data.readUInt32LE(Constants.LOCSIZ),\n        // uncompressed size\n        size: data.readUInt32LE(Constants.LOCLEN),\n        // filename length\n        fnameLen: data.readUInt16LE(Constants.LOCNAM),\n        // extra field length\n        extraLen: data.readUInt16LE(Constants.LOCEXT)\n      };\n    },\n    loadFromBinary: function loadFromBinary(\n    /*Buffer*/\n    data) {\n      // data should be 46 bytes and start with \"PK 01 02\"\n      if (data.length != Constants.CENHDR || data.readUInt32LE(0) != Constants.CENSIG) {\n        throw Utils.Errors.INVALID_CEN;\n      } // version made by\n\n\n      _verMade = data.readUInt16LE(Constants.CENVEM); // version needed to extract\n\n      _version = data.readUInt16LE(Constants.CENVER); // encrypt, decrypt flags\n\n      _flags = data.readUInt16LE(Constants.CENFLG); // compression method\n\n      _method = data.readUInt16LE(Constants.CENHOW); // modification time (2 bytes time, 2 bytes date)\n\n      _time = data.readUInt32LE(Constants.CENTIM); // uncompressed file crc-32 value\n\n      _crc = data.readUInt32LE(Constants.CENCRC); // compressed size\n\n      _compressedSize = data.readUInt32LE(Constants.CENSIZ); // uncompressed size\n\n      _size = data.readUInt32LE(Constants.CENLEN); // filename length\n\n      _fnameLen = data.readUInt16LE(Constants.CENNAM); // extra field length\n\n      _extraLen = data.readUInt16LE(Constants.CENEXT); // file comment length\n\n      _comLen = data.readUInt16LE(Constants.CENCOM); // volume number start\n\n      _diskStart = data.readUInt16LE(Constants.CENDSK); // internal file attributes\n\n      _inattr = data.readUInt16LE(Constants.CENATT); // external file attributes\n\n      _attr = data.readUInt32LE(Constants.CENATX); // LOC header offset\n\n      _offset = data.readUInt32LE(Constants.CENOFF);\n    },\n    dataHeaderToBinary: function dataHeaderToBinary() {\n      // LOC header size (30 bytes)\n      var data = new Buffer(Constants.LOCHDR); // \"PK\\003\\004\"\n\n      data.writeUInt32LE(Constants.LOCSIG, 0); // version needed to extract\n\n      data.writeUInt16LE(_version, Constants.LOCVER); // general purpose bit flag\n\n      data.writeUInt16LE(_flags, Constants.LOCFLG); // compression method\n\n      data.writeUInt16LE(_method, Constants.LOCHOW); // modification time (2 bytes time, 2 bytes date)\n\n      data.writeUInt32LE(_time, Constants.LOCTIM); // uncompressed file crc-32 value\n\n      data.writeUInt32LE(_crc, Constants.LOCCRC); // compressed size\n\n      data.writeUInt32LE(_compressedSize, Constants.LOCSIZ); // uncompressed size\n\n      data.writeUInt32LE(_size, Constants.LOCLEN); // filename length\n\n      data.writeUInt16LE(_fnameLen, Constants.LOCNAM); // extra field length\n\n      data.writeUInt16LE(_extraLen, Constants.LOCEXT);\n      return data;\n    },\n    entryHeaderToBinary: function entryHeaderToBinary() {\n      // CEN header size (46 bytes)\n      var data = new Buffer(Constants.CENHDR + _fnameLen + _extraLen + _comLen); // \"PK\\001\\002\"\n\n      data.writeUInt32LE(Constants.CENSIG, 0); // version made by\n\n      data.writeUInt16LE(_verMade, Constants.CENVEM); // version needed to extract\n\n      data.writeUInt16LE(_version, Constants.CENVER); // encrypt, decrypt flags\n\n      data.writeUInt16LE(_flags, Constants.CENFLG); // compression method\n\n      data.writeUInt16LE(_method, Constants.CENHOW); // modification time (2 bytes time, 2 bytes date)\n\n      data.writeUInt32LE(_time, Constants.CENTIM); // uncompressed file crc-32 value\n\n      data.writeInt32LE(_crc, Constants.CENCRC, true); // compressed size\n\n      data.writeUInt32LE(_compressedSize, Constants.CENSIZ); // uncompressed size\n\n      data.writeUInt32LE(_size, Constants.CENLEN); // filename length\n\n      data.writeUInt16LE(_fnameLen, Constants.CENNAM); // extra field length\n\n      data.writeUInt16LE(_extraLen, Constants.CENEXT); // file comment length\n\n      data.writeUInt16LE(_comLen, Constants.CENCOM); // volume number start\n\n      data.writeUInt16LE(_diskStart, Constants.CENDSK); // internal file attributes\n\n      data.writeUInt16LE(_inattr, Constants.CENATT); // external file attributes\n\n      data.writeUInt32LE(_attr, Constants.CENATX); // LOC header offset\n\n      data.writeUInt32LE(_offset, Constants.CENOFF); // fill all with\n\n      data.fill(0x00, Constants.CENHDR);\n      return data;\n    },\n    toString: function toString() {\n      return '{\\n' + '\\t\"made\" : ' + _verMade + \",\\n\" + '\\t\"version\" : ' + _version + \",\\n\" + '\\t\"flags\" : ' + _flags + \",\\n\" + '\\t\"method\" : ' + Utils.methodToString(_method) + \",\\n\" + '\\t\"time\" : ' + _time + \",\\n\" + '\\t\"crc\" : 0x' + _crc.toString(16).toUpperCase() + \",\\n\" + '\\t\"compressedSize\" : ' + _compressedSize + \" bytes,\\n\" + '\\t\"size\" : ' + _size + \" bytes,\\n\" + '\\t\"fileNameLength\" : ' + _fnameLen + \",\\n\" + '\\t\"extraLength\" : ' + _extraLen + \" bytes,\\n\" + '\\t\"commentLength\" : ' + _comLen + \" bytes,\\n\" + '\\t\"diskNumStart\" : ' + _diskStart + \",\\n\" + '\\t\"inAttr\" : ' + _inattr + \",\\n\" + '\\t\"attr\" : ' + _attr + \",\\n\" + '\\t\"offset\" : ' + _offset + \",\\n\" + '\\t\"entryHeaderSize\" : ' + (Constants.CENHDR + _fnameLen + _extraLen + _comLen) + \" bytes\\n\" + '}';\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}