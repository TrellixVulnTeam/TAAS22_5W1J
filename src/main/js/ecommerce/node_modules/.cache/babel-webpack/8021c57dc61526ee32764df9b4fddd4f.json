{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview Defines the {@linkplain Driver WebDriver} client for Firefox.\n * Each FirefoxDriver instance will be created with an anonymous profile,\n * ensuring browser historys do not share session data (cookies, history, cache,\n * offline storage, etc.)\n *\n * __Customizing the Firefox Profile__\n *\n * The {@link Profile} class may be used to configure the browser profile used\n * with WebDriver, with functions to install additional\n * {@linkplain Profile#addExtension extensions}, configure browser\n * {@linkplain Profile#setPreference preferences}, and more. For example, you\n * may wish to include Firebug:\n *\n *     var firefox = require('selenium-webdriver/firefox');\n *\n *     var profile = new firefox.Profile();\n *     profile.addExtension('/path/to/firebug.xpi');\n *     profile.setPreference('extensions.firebug.showChromeErrors', true);\n *\n *     var options = new firefox.Options().setProfile(profile);\n *     var driver = new firefox.Driver(options);\n *\n * The {@link Profile} class may also be used to configure WebDriver based on a\n * pre-existing browser profile:\n *\n *     var profile = new firefox.Profile(\n *         '/usr/local/home/bob/.mozilla/firefox/3fgog75h.testing');\n *     var options = new firefox.Options().setProfile(profile);\n *     var driver = new firefox.Driver(options);\n *\n * The FirefoxDriver will _never_ modify a pre-existing profile; instead it will\n * create a copy for it to modify. By extension, there are certain browser\n * preferences that are required for WebDriver to function properly and they\n * will always be overwritten.\n *\n * __Using a Custom Firefox Binary__\n *\n * On Windows and OSX, the FirefoxDriver will search for Firefox in its\n * default installation location:\n *\n * * Windows: C:\\Program Files and C:\\Program Files (x86).\n * * Mac OS X: /Applications/Firefox.app\n *\n * For Linux, Firefox will be located on the PATH: `$(where firefox)`.\n *\n * You can configure WebDriver to start use a custom Firefox installation with\n * the {@link Binary} class:\n *\n *     var firefox = require('selenium-webdriver/firefox');\n *     var binary = new firefox.Binary('/my/firefox/install/dir/firefox-bin');\n *     var options = new firefox.Options().setBinary(binary);\n *     var driver = new firefox.Driver(options);\n *\n * __Remote Testing__\n *\n * You may customize the Firefox binary and profile when running against a\n * remote Selenium server. Your custom profile will be packaged as a zip and\n * transfered to the remote host for use. The profile will be transferred\n * _once for each new session_. The performance impact should be minimal if\n * you've only configured a few extra browser preferences. If you have a large\n * profile with several extensions, you should consider installing it on the\n * remote host and defining its path via the {@link Options} class. Custom\n * binaries are never copied to remote machines and must be referenced by\n * installation path.\n *\n *     var options = new firefox.Options()\n *         .setProfile('/profile/path/on/remote/host')\n *         .setBinary('/install/dir/on/remote/host/firefox-bin');\n *\n *     var driver = new (require('selenium-webdriver')).Builder()\n *         .forBrowser('firefox')\n *         .usingServer('http://127.0.0.1:4444/wd/hub')\n *         .setFirefoxOptions(options)\n *         .build();\n */\n'use strict';\n\nvar _assertThisInitialized = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/assertThisInitialized\").default;\n\nvar _inherits = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar url = require('url');\n\nvar Binary = require('./binary').Binary,\n    Profile = require('./profile').Profile,\n    decodeProfile = require('./profile').decode,\n    executors = require('../executors'),\n    httpUtil = require('../http/util'),\n    io = require('../io'),\n    capabilities = require('../lib/capabilities'),\n    logging = require('../lib/logging'),\n    promise = require('../lib/promise'),\n    webdriver = require('../lib/webdriver'),\n    net = require('../net'),\n    portprober = require('../net/portprober'),\n    remote = require('../remote');\n/**\n * Firefox-specific capability keys. Users should use the {@linkplain Options}\n * class instead of referencing these keys directly. _These keys are considered\n * implementation details and may be removed or changed at any time._\n *\n * @enum {string}\n */\n\n\nvar Capability = {\n  /**\n   * Defines the Firefox binary to use. May be set to either a\n   * {@linkplain Binary} instance, or a string path to the Firefox executable.\n   */\n  BINARY: 'firefox_binary',\n\n  /**\n   * Specifies whether to use Mozilla's Marionette, or the legacy FirefoxDriver\n   * from the Selenium project. Defaults to false.\n   */\n  MARIONETTE: 'marionette',\n\n  /**\n   * Defines the Firefox profile to use. May be set to either a\n   * {@linkplain Profile} instance, or to a base-64 encoded zip of a profile\n   * directory.\n   */\n  PROFILE: 'firefox_profile'\n};\n/**\n * Configuration options for the FirefoxDriver.\n */\n\nvar Options = /*#__PURE__*/function () {\n  function Options() {\n    _classCallCheck(this, Options);\n\n    /** @private {Profile} */\n    this.profile_ = null;\n    /** @private {Binary} */\n\n    this.binary_ = null;\n    /** @private {logging.Preferences} */\n\n    this.logPrefs_ = null;\n    /** @private {?capabilities.ProxyConfig} */\n\n    this.proxy_ = null;\n    /** @private {boolean} */\n\n    this.marionette_ = false;\n  }\n  /**\n   * Sets the profile to use. The profile may be specified as a\n   * {@link Profile} object or as the path to an existing Firefox profile to use\n   * as a template.\n   *\n   * @param {(string|!Profile)} profile The profile to use.\n   * @return {!Options} A self reference.\n   */\n\n\n  _createClass(Options, [{\n    key: \"setProfile\",\n    value: function setProfile(profile) {\n      if (typeof profile === 'string') {\n        profile = new Profile(profile);\n      }\n\n      this.profile_ = profile;\n      return this;\n    }\n    /**\n     * Sets the binary to use. The binary may be specified as the path to a Firefox\n     * executable, or as a {@link Binary} object.\n     *\n     * @param {(string|!Binary)} binary The binary to use.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setBinary\",\n    value: function setBinary(binary) {\n      if (typeof binary === 'string') {\n        binary = new Binary(binary);\n      }\n\n      this.binary_ = binary;\n      return this;\n    }\n    /**\n     * Sets the logging preferences for the new session.\n     * @param {logging.Preferences} prefs The logging preferences.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setLoggingPreferences\",\n    value: function setLoggingPreferences(prefs) {\n      this.logPrefs_ = prefs;\n      return this;\n    }\n    /**\n     * Sets the proxy to use.\n     *\n     * @param {capabilities.ProxyConfig} proxy The proxy configuration to use.\n     * @return {!Options} A self reference.\n     */\n\n  }, {\n    key: \"setProxy\",\n    value: function setProxy(proxy) {\n      this.proxy_ = proxy;\n      return this;\n    }\n    /**\n     * Sets whether to use Mozilla's Marionette to drive the browser.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Mozilla/QA/Marionette/WebDriver\n     */\n\n  }, {\n    key: \"useMarionette\",\n    value: function useMarionette(marionette) {\n      this.marionette_ = marionette;\n      return this;\n    }\n    /**\n     * Converts these options to a {@link capabilities.Capabilities} instance.\n     *\n     * @return {!capabilities.Capabilities} A new capabilities object.\n     */\n\n  }, {\n    key: \"toCapabilities\",\n    value: function toCapabilities() {\n      var caps = capabilities.Capabilities.firefox();\n\n      if (this.logPrefs_) {\n        caps.set(capabilities.Capability.LOGGING_PREFS, this.logPrefs_);\n      }\n\n      if (this.proxy_) {\n        caps.set(capabilities.Capability.PROXY, this.proxy_);\n      }\n\n      if (this.binary_) {\n        caps.set(Capability.BINARY, this.binary_);\n      }\n\n      if (this.profile_) {\n        caps.set(Capability.PROFILE, this.profile_);\n      }\n\n      caps.set(Capability.MARIONETTE, this.marionette_);\n      return caps;\n    }\n  }]);\n\n  return Options;\n}();\n\nvar WIRES_EXE = process.platform === 'win32' ? 'wires.exe' : 'wires';\n/**\n * @return {string} .\n * @throws {Error}\n */\n\nfunction findWires() {\n  var exe = io.findInPath(WIRES_EXE, true);\n\n  if (!exe) {\n    throw Error('The ' + WIRES_EXE + ' executable could not be found on the current ' + 'PATH. Please download the latest version from ' + 'https://developer.mozilla.org/en-US/docs/Mozilla/QA/Marionette/' + 'WebDriver and ensure it can be found on your PATH.');\n  }\n\n  return exe;\n}\n/**\n * @param {(string|!Binary)} binary .\n * @return {!remote.DriverService} .\n */\n\n\nfunction createWiresService(binary) {\n  // Firefox's Developer Edition is currently required for Marionette.\n  var exe;\n\n  if (typeof binary === 'string') {\n    exe = Promise.resolve(binary);\n  } else {\n    binary.useDevEdition();\n    exe = binary.locate();\n  }\n\n  var wires = findWires();\n  var port = portprober.findFreePort();\n  return new remote.DriverService(wires, {\n    loopback: true,\n    port: port,\n    args: promise.all([exe, port]).then(function (args) {\n      return ['-b', args[0], '--webdriver-port', args[1]];\n    }) // ,stdio: 'inherit'\n\n  });\n}\n/**\n * @param {(Profile|string)} profile The profile to prepare.\n * @param {number} port The port the FirefoxDriver should listen on.\n * @return {!Promise<string>} a promise for the path to the profile directory.\n */\n\n\nfunction prepareProfile(profile, port) {\n  if (typeof profile === 'string') {\n    return decodeProfile(\n    /** @type {string} */\n    profile).then(function (dir) {\n      profile = new Profile(dir);\n      profile.setPreference('webdriver_firefox_port', port);\n      return profile.writeToDisk();\n    });\n  }\n\n  profile = profile || new Profile();\n  profile.setPreference('webdriver_firefox_port', port);\n  return profile.writeToDisk();\n}\n/**\n * A WebDriver client for Firefox.\n */\n\n\nvar Driver = /*#__PURE__*/function (_webdriver$WebDriver) {\n  _inherits(Driver, _webdriver$WebDriver);\n\n  var _super = _createSuper(Driver);\n\n  /**\n   * @param {(Options|capabilities.Capabilities|Object)=} opt_config The\n   *    configuration options for this driver, specified as either an\n   *    {@link Options} or {@link capabilities.Capabilities}, or as a raw hash\n   *    object.\n   * @param {promise.ControlFlow=} opt_flow The flow to\n   *     schedule commands through. Defaults to the active flow object.\n   */\n  function Driver(opt_config, opt_flow) {\n    var _this;\n\n    _classCallCheck(this, Driver);\n\n    var caps;\n\n    if (opt_config instanceof Options) {\n      caps = opt_config.toCapabilities();\n    } else {\n      caps = new capabilities.Capabilities(opt_config);\n    }\n\n    var binary = caps.get(Capability.BINARY) || new Binary();\n    caps.delete(Capability.BINARY);\n\n    if (typeof binary === 'string') {\n      binary = new Binary(binary);\n    }\n\n    var profile = new Profile();\n\n    if (caps.has(Capability.PROFILE)) {\n      profile = caps.get(Capability.PROFILE);\n      caps.delete(Capability.PROFILE);\n    }\n\n    var freePort = portprober.findFreePort();\n    var serverUrl, onQuit;\n\n    if (caps.get(Capability.MARIONETTE) || /^1|true$/i.test(process.env['SELENIUM_MARIONETTE'])) {\n      var service = createWiresService(binary);\n      serverUrl = service.start();\n\n      onQuit = function onQuit() {\n        return service.kill();\n      };\n    } else {\n      var preparedProfile = freePort.then(function (port) {\n        return prepareProfile(profile, port);\n      });\n      var command = preparedProfile.then(function (dir) {\n        return binary.launch(dir);\n      });\n      serverUrl = command.then(function () {\n        return freePort;\n      }).then(function (\n      /** number */\n      port) {\n        var serverUrl = url.format({\n          protocol: 'http',\n          hostname: net.getLoopbackAddress(),\n          port: port + '',\n          pathname: '/hub'\n        });\n        var ready = httpUtil.waitForServer(serverUrl, 45 * 1000);\n        return ready.then(function () {\n          return serverUrl;\n        });\n      });\n\n      onQuit = function onQuit() {\n        var finishCommand = command.then(function (command) {\n          command.kill();\n          return command.result();\n        });\n        return finishCommand.finally(function () {\n          return preparedProfile.then(io.rmDir);\n        });\n      };\n    }\n\n    var executor = executors.createExecutor(serverUrl);\n    var driver = webdriver.WebDriver.createSession(executor, caps, opt_flow);\n    _this = _super.call(this, driver.getSession(), executor, driver.controlFlow());\n\n    var boundQuit = _this.quit.bind(_assertThisInitialized(_this));\n    /** @override */\n\n\n    _this.quit = function () {\n      return boundQuit().thenFinally(onQuit);\n    };\n\n    return _this;\n  }\n  /**\n   * This function is a no-op as file detectors are not supported by this\n   * implementation.\n   * @override\n   */\n\n\n  _createClass(Driver, [{\n    key: \"setFileDetector\",\n    value: function setFileDetector() {}\n  }]);\n\n  return Driver;\n}(webdriver.WebDriver); // PUBLIC API\n\n\nexports.Binary = Binary;\nexports.Driver = Driver;\nexports.Options = Options;\nexports.Profile = Profile;","map":null,"metadata":{},"sourceType":"script"}