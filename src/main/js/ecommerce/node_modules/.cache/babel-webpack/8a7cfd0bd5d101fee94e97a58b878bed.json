{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs = require(\"fs\");\n\nvar config_1 = require(\"../config\");\n/**\n * operating system enum\n */\n\n\nvar OS;\n\n(function (OS) {\n  OS[OS[\"Windows_NT\"] = 0] = \"Windows_NT\";\n  OS[OS[\"Linux\"] = 1] = \"Linux\";\n  OS[OS[\"Darwin\"] = 2] = \"Darwin\";\n})(OS = exports.OS || (exports.OS = {}));\n\nvar Binary = /*#__PURE__*/function () {\n  function Binary(opt_alternativeCdn) {\n    _classCallCheck(this, Binary);\n\n    this.ostype = config_1.Config.osType();\n    this.osarch = config_1.Config.osArch();\n    this.cdn = opt_alternativeCdn;\n  }\n\n  _createClass(Binary, [{\n    key: \"executableSuffix\",\n    value: function executableSuffix() {\n      if (this.ostype == 'Windows_NT') {\n        return '.exe';\n      } else {\n        return '';\n      }\n    }\n  }, {\n    key: \"version\",\n    value: function version() {\n      return this.versionCustom;\n    }\n  }, {\n    key: \"filename\",\n    value: function filename() {\n      return this.prefix() + this.version() + this.suffix();\n    }\n    /**\n     * @param ostype The operating system.\n     * @returns The file name for the executable.\n     */\n\n  }, {\n    key: \"executableFilename\",\n    value: function executableFilename() {\n      return this.prefix() + this.version() + this.executableSuffix();\n    }\n    /**\n     * Gets the url to download the file set by the version. This will use the XML if available.\n     * If not, it will download from an existing url.\n     *\n     * @param {string} version The version we are looking for. This could also be 'latest'.\n     */\n\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(version) {\n      var _this = this;\n\n      if (this.alternativeDownloadUrl != null) {\n        return Promise.resolve({\n          url: '',\n          version: ''\n        });\n      } else {\n        return this.getVersionList().then(function () {\n          version = version || config_1.Config.binaryVersions()[_this.id()];\n          return _this.configSource.getUrl(version).then(function (binaryUrl) {\n            _this.versionCustom = binaryUrl.version;\n            return {\n              url: binaryUrl.url,\n              version: binaryUrl.version\n            };\n          });\n        });\n      }\n    }\n    /**\n     * Delete an instance of this binary from the file system\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(filename) {\n      fs.unlinkSync(filename);\n    }\n    /**\n     * @param ostype The operating system.\n     * @returns The file name for the file inside the downloaded zip file\n     */\n\n  }, {\n    key: \"zipContentName\",\n    value: function zipContentName() {\n      return this.name + this.executableSuffix();\n    }\n  }]);\n\n  return Binary;\n}();\n\nexports.Binary = Binary; //# sourceMappingURL=binary.js.map","map":null,"metadata":{},"sourceType":"script"}