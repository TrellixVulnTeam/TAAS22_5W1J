{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _inherits = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar request = require(\"request\");\n\nvar url = require(\"url\");\n\nvar xml2js = require(\"xml2js\");\n\nvar logger_1 = require(\"../cli/logger\");\n\nvar config_1 = require(\"../config\");\n\nvar http_utils_1 = require(\"../http_utils\");\n\nvar logger = new logger_1.Logger('config_source');\n\nvar ConfigSource = function ConfigSource() {\n  _classCallCheck(this, ConfigSource);\n\n  this.ostype = config_1.Config.osType();\n  this.osarch = config_1.Config.osArch();\n  this.out_dir = config_1.Config.getSeleniumDir();\n};\n\nexports.ConfigSource = ConfigSource;\n\nvar XmlConfigSource = /*#__PURE__*/function (_ConfigSource) {\n  _inherits(XmlConfigSource, _ConfigSource);\n\n  var _super = _createSuper(XmlConfigSource);\n\n  function XmlConfigSource(name, xmlUrl) {\n    var _this;\n\n    _classCallCheck(this, XmlConfigSource);\n\n    _this = _super.call(this);\n    _this.name = name;\n    _this.xmlUrl = xmlUrl;\n    return _this;\n  }\n\n  _createClass(XmlConfigSource, [{\n    key: \"getFileName\",\n    value: function getFileName() {\n      try {\n        fs.statSync(this.out_dir);\n      } catch (e) {\n        fs.mkdirSync(this.out_dir);\n      }\n\n      return path.resolve(this.out_dir, this.name + '-response.xml');\n    }\n  }, {\n    key: \"getXml\",\n    value: function getXml() {\n      var _this2 = this;\n\n      var fileName = this.getFileName();\n      var content = this.readResponse();\n\n      if (content) {\n        return Promise.resolve(content);\n      } else {\n        return this.requestXml().then(function (text) {\n          var xml = _this2.convertXml2js(text);\n\n          fs.writeFileSync(fileName, text);\n          return xml;\n        });\n      }\n    }\n  }, {\n    key: \"readResponse\",\n    value: function readResponse() {\n      var fileName = this.getFileName();\n\n      try {\n        var contents = fs.readFileSync(fileName).toString();\n        var timestamp = new Date(fs.statSync(fileName).mtime).getTime();\n        var size = fs.statSync(fileName).size;\n        var now = Date.now(); // On start, read the file. If not on start, check use the cache as long as the\n        // size > 0 and within the cache time.\n        // 60 minutes * 60 seconds / minute * 1000 ms / second\n\n        if (config_1.Config.runCommand === 'start' || size > 0 && now - 60 * 60 * 1000 < timestamp) {\n          return this.convertXml2js(contents);\n        } else {\n          return null;\n        }\n      } catch (err) {\n        return null;\n      }\n    }\n  }, {\n    key: \"requestXml\",\n    value: function requestXml() {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        var options = http_utils_1.HttpUtils.initOptions(_this3.xmlUrl);\n        var curl = _this3.getFileName() + ' ' + options.url;\n\n        if (http_utils_1.HttpUtils.requestOpts.proxy) {\n          var pathUrl = url.parse(options.url.toString()).path;\n          var host = url.parse(options.url.toString()).host;\n          var newFileUrl = url.resolve(http_utils_1.HttpUtils.requestOpts.proxy, pathUrl);\n          curl = _this3.getFileName() + ' \\'' + newFileUrl + '\\' -H \\'host:' + host + '\\'';\n        }\n\n        if (http_utils_1.HttpUtils.requestOpts.ignoreSSL) {\n          curl = 'k ' + curl;\n        }\n\n        logger.info('curl -o' + curl);\n        var req = request(options);\n        req.on('response', function (response) {\n          if (response.statusCode === 200) {\n            var output = '';\n            response.on('data', function (data) {\n              output += data;\n            });\n            response.on('end', function () {\n              resolve(output);\n            });\n          } else {\n            reject(new Error('response status code is not 200'));\n          }\n        });\n      });\n    }\n  }, {\n    key: \"convertXml2js\",\n    value: function convertXml2js(xml) {\n      var retResult = null;\n      xml2js.parseString(xml, function (err, result) {\n        retResult = result;\n      });\n      return retResult;\n    }\n  }]);\n\n  return XmlConfigSource;\n}(ConfigSource);\n\nexports.XmlConfigSource = XmlConfigSource;\n\nvar JsonConfigSource = /*#__PURE__*/function (_ConfigSource2) {\n  _inherits(JsonConfigSource, _ConfigSource2);\n\n  var _super2 = _createSuper(JsonConfigSource);\n\n  function JsonConfigSource(name, jsonUrl) {\n    var _this4;\n\n    _classCallCheck(this, JsonConfigSource);\n\n    _this4 = _super2.call(this);\n    _this4.name = name;\n    _this4.jsonUrl = jsonUrl;\n    return _this4;\n  }\n\n  _createClass(JsonConfigSource, [{\n    key: \"getFileName\",\n    value: function getFileName() {\n      try {\n        fs.statSync(this.out_dir);\n      } catch (e) {\n        fs.mkdirSync(this.out_dir);\n      }\n\n      return path.resolve(this.out_dir, this.name + '-response.json');\n    }\n  }]);\n\n  return JsonConfigSource;\n}(ConfigSource);\n\nexports.JsonConfigSource = JsonConfigSource;\n\nvar GithubApiConfigSource = /*#__PURE__*/function (_JsonConfigSource) {\n  _inherits(GithubApiConfigSource, _JsonConfigSource);\n\n  var _super3 = _createSuper(GithubApiConfigSource);\n\n  function GithubApiConfigSource(name, url) {\n    _classCallCheck(this, GithubApiConfigSource);\n\n    return _super3.call(this, name, url);\n  }\n  /**\n   * This is an unauthenticated request and since Github limits the rate, we will cache this\n   * to a file. { timestamp: number, response: response }. We will check the timestamp and renew\n   * this request if the file is older than an hour.\n   */\n\n\n  _createClass(GithubApiConfigSource, [{\n    key: \"getJson\",\n    value: function getJson() {\n      var fileName = this.getFileName();\n      var content = this.readResponse();\n\n      if (content) {\n        return Promise.resolve(JSON.parse(content));\n      } else {\n        return this.requestJson().then(function (body) {\n          var json = JSON.parse(body);\n          fs.writeFileSync(fileName, JSON.stringify(json, null, '  '));\n          return json;\n        });\n      }\n    }\n  }, {\n    key: \"requestJson\",\n    value: function requestJson() {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        var options = http_utils_1.HttpUtils.initOptions(_this5.jsonUrl);\n        options = http_utils_1.HttpUtils.optionsHeader(options, 'Host', 'api.github.com');\n        options = http_utils_1.HttpUtils.optionsHeader(options, 'User-Agent', 'request');\n        var curl = _this5.getFileName() + ' ' + options.url;\n\n        if (http_utils_1.HttpUtils.requestOpts.proxy) {\n          var pathUrl = url.parse(options.url.toString()).path;\n          var host = url.parse(options.url.toString()).host;\n          var newFileUrl = url.resolve(http_utils_1.HttpUtils.requestOpts.proxy, pathUrl);\n          curl = _this5.getFileName() + ' \\'' + newFileUrl + '\\' -H \\'host:' + host + '\\'';\n        }\n\n        if (http_utils_1.HttpUtils.requestOpts.ignoreSSL) {\n          curl = 'k ' + curl;\n        }\n\n        logger.info('curl -o' + curl);\n        var req = request(options);\n        req.on('response', function (response) {\n          if (response.statusCode === 200) {\n            var output = '';\n            response.on('data', function (data) {\n              output += data;\n            });\n            response.on('end', function () {\n              resolve(output);\n            });\n          } else if (response.statusCode == 403 && response.headers['x-ratelimit-remaining'] == '0') {\n            reject(new Error('Failed to make Github request, rate limit reached.'));\n          } else {\n            reject(new Error('response status code is not 200.  It was ' + response.statusCode));\n          }\n        });\n      });\n    }\n  }, {\n    key: \"readResponse\",\n    value: function readResponse() {\n      var fileName = this.getFileName();\n\n      try {\n        var contents = fs.readFileSync(fileName).toString();\n        var timestamp = new Date(fs.statSync(fileName).mtime).getTime();\n        var size = fs.statSync(fileName).size;\n        var now = Date.now(); // On start, read the file. If not on start, check use the cache as long as the\n        // size > 0 and within the cache time.\n        // 60 minutes * 60 seconds / minute * 1000 ms / second\n\n        if (config_1.Config.runCommand === 'start' || size > 0 && now - 60 * 60 * 1000 < timestamp) {\n          return contents;\n        } else {\n          return null;\n        }\n      } catch (err) {\n        return null;\n      }\n    }\n  }]);\n\n  return GithubApiConfigSource;\n}(JsonConfigSource);\n\nexports.GithubApiConfigSource = GithubApiConfigSource; //# sourceMappingURL=config_source.js.map","map":null,"metadata":{},"sourceType":"script"}