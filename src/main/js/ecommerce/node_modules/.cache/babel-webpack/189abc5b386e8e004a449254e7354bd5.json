{"ast":null,"code":"var Buffer = require(\"buffer\").Buffer;\n\nfunction JSInflater(\n/*Buffer*/\ninput) {\n  var WSIZE = 0x8000,\n      slide = new Buffer(0x10000),\n      windowPos = 0,\n      fixedTableList = null,\n      fixedTableDist,\n      fixedLookup,\n      bitBuf = 0,\n      bitLen = 0,\n      method = -1,\n      eof = false,\n      copyLen = 0,\n      copyDist = 0,\n      tblList,\n      tblDist,\n      bitList,\n      bitdist,\n      inputPosition = 0,\n      MASK_BITS = [0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff],\n      LENS = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],\n      LEXT = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99],\n      DISTS = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],\n      DEXT = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],\n      BITORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n  function HuffTable(clen, cnum, cval, blist, elist, lookupm) {\n    this.status = 0;\n    this.root = null;\n    this.maxbit = 0;\n    var el,\n        f,\n        tail,\n        offsets = [],\n        countTbl = [],\n        sTbl = [],\n        values = [],\n        tentry = {\n      extra: 0,\n      bitcnt: 0,\n      lbase: 0,\n      next: null\n    };\n    tail = this.root = null;\n\n    for (var i = 0; i < 0x11; i++) {\n      countTbl[i] = 0;\n      sTbl[i] = 0;\n      offsets[i] = 0;\n    }\n\n    for (i = 0; i < 0x120; i++) {\n      values[i] = 0;\n    }\n\n    el = cnum > 256 ? clen[256] : 16;\n    var pidx = -1;\n\n    while (++pidx < cnum) {\n      countTbl[clen[pidx]]++;\n    }\n\n    if (countTbl[0] == cnum) return;\n\n    for (var j = 1; j <= 16; j++) {\n      if (countTbl[j] != 0) break;\n    }\n\n    var bitLen = j;\n\n    for (i = 16; i != 0; i--) {\n      if (countTbl[i] != 0) break;\n    }\n\n    var maxLen = i;\n    lookupm < j && (lookupm = j);\n    var dCodes = 1 << j;\n\n    for (; j < i; j++, dCodes <<= 1) {\n      if ((dCodes -= countTbl[j]) < 0) {\n        this.status = 2;\n        this.maxbit = lookupm;\n        return;\n      }\n    }\n\n    if ((dCodes -= countTbl[i]) < 0) {\n      this.status = 2;\n      this.maxbit = lookupm;\n      return;\n    }\n\n    countTbl[i] += dCodes;\n    offsets[1] = j = 0;\n    pidx = 1;\n    var xp = 2;\n\n    while (--i > 0) {\n      offsets[xp++] = j += countTbl[pidx++];\n    }\n\n    pidx = 0;\n    i = 0;\n\n    do {\n      (j = clen[pidx++]) && (values[offsets[j]++] = i);\n    } while (++i < cnum);\n\n    cnum = offsets[maxLen];\n    offsets[0] = i = 0;\n    pidx = 0;\n    var level = -1,\n        w = sTbl[0] = 0,\n        cnode = null,\n        tblCnt = 0,\n        tblStack = [];\n\n    for (; bitLen <= maxLen; bitLen++) {\n      var kccnt = countTbl[bitLen];\n\n      while (kccnt-- > 0) {\n        while (bitLen > w + sTbl[1 + level]) {\n          w += sTbl[1 + level];\n          level++;\n          tblCnt = (tblCnt = maxLen - w) > lookupm ? lookupm : tblCnt;\n\n          if ((f = 1 << (j = bitLen - w)) > kccnt + 1) {\n            f -= kccnt + 1;\n            xp = bitLen;\n\n            while (++j < tblCnt) {\n              if ((f <<= 1) <= countTbl[++xp]) break;\n              f -= countTbl[xp];\n            }\n          }\n\n          if (w + j > el && w < el) j = el - w;\n          tblCnt = 1 << j;\n          sTbl[1 + level] = j;\n          cnode = [];\n\n          while (cnode.length < tblCnt) {\n            cnode.push({\n              extra: 0,\n              bitcnt: 0,\n              lbase: 0,\n              next: null\n            });\n          }\n\n          if (tail == null) {\n            tail = this.root = {\n              next: null,\n              list: null\n            };\n          } else {\n            tail = tail.next = {\n              next: null,\n              list: null\n            };\n          }\n\n          tail.next = null;\n          tail.list = cnode;\n          tblStack[level] = cnode;\n\n          if (level > 0) {\n            offsets[level] = i;\n            tentry.bitcnt = sTbl[level];\n            tentry.extra = 16 + j;\n            tentry.next = cnode;\n            j = (i & (1 << w) - 1) >> w - sTbl[level];\n            tblStack[level - 1][j].extra = tentry.extra;\n            tblStack[level - 1][j].bitcnt = tentry.bitcnt;\n            tblStack[level - 1][j].lbase = tentry.lbase;\n            tblStack[level - 1][j].next = tentry.next;\n          }\n        }\n\n        tentry.bitcnt = bitLen - w;\n        if (pidx >= cnum) tentry.extra = 99;else if (values[pidx] < cval) {\n          tentry.extra = values[pidx] < 256 ? 16 : 15;\n          tentry.lbase = values[pidx++];\n        } else {\n          tentry.extra = elist[values[pidx] - cval];\n          tentry.lbase = blist[values[pidx++] - cval];\n        }\n        f = 1 << bitLen - w;\n\n        for (j = i >> w; j < tblCnt; j += f) {\n          cnode[j].extra = tentry.extra;\n          cnode[j].bitcnt = tentry.bitcnt;\n          cnode[j].lbase = tentry.lbase;\n          cnode[j].next = tentry.next;\n        }\n\n        for (j = 1 << bitLen - 1; (i & j) != 0; j >>= 1) {\n          i ^= j;\n        }\n\n        i ^= j;\n\n        while ((i & (1 << w) - 1) != offsets[level]) {\n          w -= sTbl[level];\n          level--;\n        }\n      }\n    }\n\n    this.maxbit = sTbl[1];\n    this.status = dCodes != 0 && maxLen != 1 ? 1 : 0;\n  }\n\n  function addBits(n) {\n    while (bitLen < n) {\n      bitBuf |= input[inputPosition++] << bitLen;\n      bitLen += 8;\n    }\n\n    return bitBuf;\n  }\n\n  function cutBits(n) {\n    bitLen -= n;\n    return bitBuf >>= n;\n  }\n\n  function maskBits(n) {\n    while (bitLen < n) {\n      bitBuf |= input[inputPosition++] << bitLen;\n      bitLen += 8;\n    }\n\n    var res = bitBuf & MASK_BITS[n];\n    bitBuf >>= n;\n    bitLen -= n;\n    return res;\n  }\n\n  function codes(buff, off, size) {\n    var e, t;\n    if (size == 0) return 0;\n    var n = 0;\n\n    for (;;) {\n      t = tblList.list[addBits(bitList) & MASK_BITS[bitList]];\n      e = t.extra;\n\n      while (e > 16) {\n        if (e == 99) return -1;\n        cutBits(t.bitcnt);\n        e -= 16;\n        t = t.next[addBits(e) & MASK_BITS[e]];\n        e = t.extra;\n      }\n\n      cutBits(t.bitcnt);\n\n      if (e == 16) {\n        windowPos &= WSIZE - 1;\n        buff[off + n++] = slide[windowPos++] = t.lbase;\n        if (n == size) return size;\n        continue;\n      }\n\n      if (e == 15) break;\n      copyLen = t.lbase + maskBits(e);\n      t = tblDist.list[addBits(bitdist) & MASK_BITS[bitdist]];\n      e = t.extra;\n\n      while (e > 16) {\n        if (e == 99) return -1;\n        cutBits(t.bitcnt);\n        e -= 16;\n        t = t.next[addBits(e) & MASK_BITS[e]];\n        e = t.extra;\n      }\n\n      cutBits(t.bitcnt);\n      copyDist = windowPos - t.lbase - maskBits(e);\n\n      while (copyLen > 0 && n < size) {\n        copyLen--;\n        copyDist &= WSIZE - 1;\n        windowPos &= WSIZE - 1;\n        buff[off + n++] = slide[windowPos++] = slide[copyDist++];\n      }\n\n      if (n == size) return size;\n    }\n\n    method = -1; // done\n\n    return n;\n  }\n\n  function stored(buff, off, size) {\n    cutBits(bitLen & 7);\n    var n = maskBits(0x10);\n    if (n != (~maskBits(0x10) & 0xffff)) return -1;\n    copyLen = n;\n    n = 0;\n\n    while (copyLen > 0 && n < size) {\n      copyLen--;\n      windowPos &= WSIZE - 1;\n      buff[off + n++] = slide[windowPos++] = maskBits(8);\n    }\n\n    if (copyLen == 0) method = -1;\n    return n;\n  }\n\n  function fixed(buff, off, size) {\n    var fixed_bd = 0;\n\n    if (fixedTableList == null) {\n      var lengths = [];\n\n      for (var symbol = 0; symbol < 144; symbol++) {\n        lengths[symbol] = 8;\n      }\n\n      for (; symbol < 256; symbol++) {\n        lengths[symbol] = 9;\n      }\n\n      for (; symbol < 280; symbol++) {\n        lengths[symbol] = 7;\n      }\n\n      for (; symbol < 288; symbol++) {\n        lengths[symbol] = 8;\n      }\n\n      fixedLookup = 7;\n      var htbl = new HuffTable(lengths, 288, 257, LENS, LEXT, fixedLookup);\n      if (htbl.status != 0) return -1;\n      fixedTableList = htbl.root;\n      fixedLookup = htbl.maxbit;\n\n      for (symbol = 0; symbol < 30; symbol++) {\n        lengths[symbol] = 5;\n      }\n\n      fixed_bd = 5;\n      htbl = new HuffTable(lengths, 30, 0, DISTS, DEXT, fixed_bd);\n\n      if (htbl.status > 1) {\n        fixedTableList = null;\n        return -1;\n      }\n\n      fixedTableDist = htbl.root;\n      fixed_bd = htbl.maxbit;\n    }\n\n    tblList = fixedTableList;\n    tblDist = fixedTableDist;\n    bitList = fixedLookup;\n    bitdist = fixed_bd;\n    return codes(buff, off, size);\n  }\n\n  function dynamic(buff, off, size) {\n    var ll = new Array(0x023C);\n\n    for (var m = 0; m < 0x023C; m++) {\n      ll[m] = 0;\n    }\n\n    var llencnt = 257 + maskBits(5),\n        dcodescnt = 1 + maskBits(5),\n        bitlencnt = 4 + maskBits(4);\n    if (llencnt > 286 || dcodescnt > 30) return -1;\n\n    for (var j = 0; j < bitlencnt; j++) {\n      ll[BITORDER[j]] = maskBits(3);\n    }\n\n    for (; j < 19; j++) {\n      ll[BITORDER[j]] = 0;\n    } // build decoding table for trees--single level, 7 bit lookup\n\n\n    bitList = 7;\n    var hufTable = new HuffTable(ll, 19, 19, null, null, bitList);\n    if (hufTable.status != 0) return -1; // incomplete code set\n\n    tblList = hufTable.root;\n    bitList = hufTable.maxbit;\n    var lencnt = llencnt + dcodescnt,\n        i = 0,\n        lastLen = 0;\n\n    while (i < lencnt) {\n      var hufLcode = tblList.list[addBits(bitList) & MASK_BITS[bitList]];\n      j = hufLcode.bitcnt;\n      cutBits(j);\n      j = hufLcode.lbase;\n      if (j < 16) ll[i++] = lastLen = j;else if (j == 16) {\n        j = 3 + maskBits(2);\n        if (i + j > lencnt) return -1;\n\n        while (j-- > 0) {\n          ll[i++] = lastLen;\n        }\n      } else if (j == 17) {\n        j = 3 + maskBits(3);\n        if (i + j > lencnt) return -1;\n\n        while (j-- > 0) {\n          ll[i++] = 0;\n        }\n\n        lastLen = 0;\n      } else {\n        j = 11 + maskBits(7);\n        if (i + j > lencnt) return -1;\n\n        while (j-- > 0) {\n          ll[i++] = 0;\n        }\n\n        lastLen = 0;\n      }\n    }\n\n    bitList = 9;\n    hufTable = new HuffTable(ll, llencnt, 257, LENS, LEXT, bitList);\n    bitList == 0 && (hufTable.status = 1);\n    if (hufTable.status != 0) return -1;\n    tblList = hufTable.root;\n    bitList = hufTable.maxbit;\n\n    for (i = 0; i < dcodescnt; i++) {\n      ll[i] = ll[i + llencnt];\n    }\n\n    bitdist = 6;\n    hufTable = new HuffTable(ll, dcodescnt, 0, DISTS, DEXT, bitdist);\n    tblDist = hufTable.root;\n    bitdist = hufTable.maxbit;\n    if (bitdist == 0 && llencnt > 257 || hufTable.status != 0) return -1;\n    return codes(buff, off, size);\n  }\n\n  return {\n    inflate: function inflate(\n    /*Buffer*/\n    outputBuffer) {\n      tblList = null;\n      var size = outputBuffer.length,\n          offset = 0,\n          i;\n\n      while (offset < size) {\n        if (eof && method == -1) return;\n\n        if (copyLen > 0) {\n          if (method != 0) {\n            while (copyLen > 0 && offset < size) {\n              copyLen--;\n              copyDist &= WSIZE - 1;\n              windowPos &= WSIZE - 1;\n              outputBuffer[offset++] = slide[windowPos++] = slide[copyDist++];\n            }\n          } else {\n            while (copyLen > 0 && offset < size) {\n              copyLen--;\n              windowPos &= WSIZE - 1;\n              outputBuffer[offset++] = slide[windowPos++] = maskBits(8);\n            }\n\n            copyLen == 0 && (method = -1); // done\n          }\n\n          if (offset == size) return;\n        }\n\n        if (method == -1) {\n          if (eof) break;\n          eof = maskBits(1) != 0;\n          method = maskBits(2);\n          tblList = null;\n          copyLen = 0;\n        }\n\n        switch (method) {\n          case 0:\n            i = stored(outputBuffer, offset, size - offset);\n            break;\n\n          case 1:\n            i = tblList != null ? codes(outputBuffer, offset, size - offset) : fixed(outputBuffer, offset, size - offset);\n            break;\n\n          case 2:\n            i = tblList != null ? codes(outputBuffer, offset, size - offset) : dynamic(outputBuffer, offset, size - offset);\n            break;\n\n          default:\n            i = -1;\n            break;\n        }\n\n        if (i == -1) return;\n        offset += i;\n      }\n    }\n  };\n}\n\nmodule.exports = function (\n/*Buffer*/\ninbuf) {\n  var zlib = require(\"zlib\");\n\n  return {\n    inflateAsync: function inflateAsync(\n    /*Function*/\n    callback) {\n      var tmp = zlib.createInflateRaw(),\n          parts = [],\n          total = 0;\n      tmp.on('data', function (data) {\n        parts.push(data);\n        total += data.length;\n      });\n      tmp.on('end', function () {\n        var buf = new Buffer(total),\n            written = 0;\n        buf.fill(0);\n\n        for (var i = 0; i < parts.length; i++) {\n          var part = parts[i];\n          part.copy(buf, written);\n          written += part.length;\n        }\n\n        callback && callback(buf);\n      });\n      tmp.end(inbuf);\n    },\n    inflate: function inflate(\n    /*Buffer*/\n    outputBuffer) {\n      var x = {\n        x: new JSInflater(inbuf)\n      };\n      x.x.inflate(outputBuffer);\n      delete x.x;\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}