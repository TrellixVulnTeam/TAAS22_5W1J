{"ast":null,"code":"var ZipEntry = require(\"./zipEntry\"),\n    Headers = require(\"./headers\"),\n    Utils = require(\"./util\");\n\nmodule.exports = function (\n/*String|Buffer*/\ninput,\n/*Number*/\ninputType) {\n  var entryList = [],\n      entryTable = {},\n      _comment = new Buffer(0),\n      filename = \"\",\n      fs = require(\"fs\"),\n      inBuffer = null,\n      mainHeader = new Headers.MainHeader();\n\n  if (inputType == Utils.Constants.FILE) {\n    // is a filename\n    filename = input;\n    inBuffer = fs.readFileSync(filename);\n    readMainHeader();\n  } else if (inputType == Utils.Constants.BUFFER) {\n    // is a memory buffer\n    inBuffer = input;\n    readMainHeader();\n  } else {// none. is a new file\n  }\n\n  function readEntries() {\n    entryTable = {};\n    entryList = new Array(mainHeader.diskEntries); // total number of entries\n\n    var index = mainHeader.offset; // offset of first CEN header\n\n    for (var i = 0; i < entryList.length; i++) {\n      var tmp = index,\n          entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n\n      if (entry.header.extraLength) {\n        entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\n      }\n\n      if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n      index += entry.header.entryHeaderSize;\n      entryList[i] = entry;\n      entryTable[entry.entryName] = entry;\n    }\n  }\n\n  function readMainHeader() {\n    var i = inBuffer.length - Utils.Constants.ENDHDR,\n        // END header size\n    n = Math.max(0, i - 0xFFFF),\n        // 0xFFFF is the max zip file comment length\n    endOffset = 0; // Start offset of the END header\n\n    for (i; i >= n; i--) {\n      if (inBuffer[i] != 0x50) continue; // quick check that the byte is 'P'\n\n      if (inBuffer.readUInt32LE(i) == Utils.Constants.ENDSIG) {\n        // \"PK\\005\\006\"\n        endOffset = i;\n        break;\n      }\n    }\n\n    if (!endOffset) throw Utils.Errors.INVALID_FORMAT;\n    mainHeader.loadFromBinary(inBuffer.slice(endOffset, endOffset + Utils.Constants.ENDHDR));\n\n    if (mainHeader.commentLength) {\n      _comment = inBuffer.slice(endOffset + Utils.Constants.ENDHDR);\n    }\n\n    readEntries();\n  }\n\n  return {\n    /**\r\n     * Returns an array of ZipEntry objects existent in the current opened archive\r\n     * @return Array\r\n     */\n    get entries() {\n      return entryList;\n    },\n\n    /**\r\n     * Archive comment\r\n     * @return {String}\r\n     */\n    get comment() {\n      return _comment.toString();\n    },\n\n    set comment(val) {\n      mainHeader.commentLength = val.length;\n      _comment = val;\n    },\n\n    /**\r\n     * Returns a reference to the entry with the given name or null if entry is inexistent\r\n     *\r\n     * @param entryName\r\n     * @return ZipEntry\r\n     */\n    getEntry: function getEntry(\n    /*String*/\n    entryName) {\n      return entryTable[entryName] || null;\n    },\n\n    /**\r\n     * Adds the given entry to the entry list\r\n     *\r\n     * @param entry\r\n     */\n    setEntry: function setEntry(\n    /*ZipEntry*/\n    entry) {\n      entryList.push(entry);\n      entryTable[entry.entryName] = entry;\n      mainHeader.totalEntries = entryList.length;\n    },\n\n    /**\r\n     * Removes the entry with the given name from the entry list.\r\n     *\r\n     * If the entry is a directory, then all nested files and directories will be removed\r\n     * @param entryName\r\n     */\n    deleteEntry: function deleteEntry(\n    /*String*/\n    entryName) {\n      var entry = entryTable[entryName];\n\n      if (entry && entry.isDirectory) {\n        var _self = this;\n\n        this.getEntryChildren(entry).forEach(function (child) {\n          if (child.entryName != entryName) {\n            _self.deleteEntry(child.entryName);\n          }\n        });\n      }\n\n      entryList.splice(entryList.indexOf(entry), 1);\n      delete entryTable[entryName];\n      mainHeader.totalEntries = entryList.length;\n    },\n\n    /**\r\n     *  Iterates and returns all nested files and directories of the given entry\r\n     *\r\n     * @param entry\r\n     * @return Array\r\n     */\n    getEntryChildren: function getEntryChildren(\n    /*ZipEntry*/\n    entry) {\n      if (entry.isDirectory) {\n        var list = [],\n            name = entry.entryName,\n            len = name.length;\n        entryList.forEach(function (zipEntry) {\n          if (zipEntry.entryName.substr(0, len) == name) {\n            list.push(zipEntry);\n          }\n        });\n        return list;\n      }\n\n      return [];\n    },\n\n    /**\r\n     * Returns the zip file\r\n     *\r\n     * @return Buffer\r\n     */\n    compressToBuffer: function compressToBuffer() {\n      if (entryList.length > 1) {\n        entryList.sort(function (a, b) {\n          var nameA = a.entryName.toLowerCase();\n          var nameB = b.entryName.toLowerCase();\n\n          if (nameA < nameB) {\n            return -1;\n          }\n\n          if (nameA > nameB) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      var totalSize = 0,\n          dataBlock = [],\n          entryHeaders = [],\n          dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n      entryList.forEach(function (entry) {\n        entry.header.offset = dindex; // compress data and set local and entry header accordingly. Reason why is called first\n\n        var compressedData = entry.getCompressedData(); // data header\n\n        var dataHeader = entry.header.dataHeaderToBinary();\n        var postHeader = new Buffer(entry.entryName + entry.extra.toString());\n        var dataLength = dataHeader.length + postHeader.length + compressedData.length;\n        dindex += dataLength;\n        dataBlock.push(dataHeader);\n        dataBlock.push(postHeader);\n        dataBlock.push(compressedData);\n        var entryHeader = entry.packHeader();\n        entryHeaders.push(entryHeader);\n        mainHeader.size += entryHeader.length;\n        totalSize += dataLength + entryHeader.length;\n      });\n      totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n      // point to end of data and begining of central directory first record\n\n      mainHeader.offset = dindex;\n      dindex = 0;\n      var outBuffer = new Buffer(totalSize);\n      dataBlock.forEach(function (content) {\n        content.copy(outBuffer, dindex); // write data blocks\n\n        dindex += content.length;\n      });\n      entryHeaders.forEach(function (content) {\n        content.copy(outBuffer, dindex); // write central directory entries\n\n        dindex += content.length;\n      });\n      var mh = mainHeader.toBinary();\n\n      if (_comment) {\n        _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n\n      }\n\n      mh.copy(outBuffer, dindex); // write main header\n\n      return outBuffer;\n    },\n    toAsyncBuffer: function toAsyncBuffer(\n    /*Function*/\n    onSuccess,\n    /*Function*/\n    onFail,\n    /*Function*/\n    onItemStart,\n    /*Function*/\n    onItemEnd) {\n      if (entryList.length > 1) {\n        entryList.sort(function (a, b) {\n          var nameA = a.entryName.toLowerCase();\n          var nameB = b.entryName.toLowerCase();\n\n          if (nameA > nameB) {\n            return -1;\n          }\n\n          if (nameA < nameB) {\n            return 1;\n          }\n\n          return 0;\n        });\n      }\n\n      var totalSize = 0,\n          dataBlock = [],\n          entryHeaders = [],\n          dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n\n      var compress = function compress(entryList) {\n        var self = arguments.callee;\n        var entry;\n\n        if (entryList.length) {\n          var entry = entryList.pop();\n          var name = entry.entryName + entry.extra.toString();\n          if (onItemStart) onItemStart(name);\n          entry.getCompressedDataAsync(function (compressedData) {\n            if (onItemEnd) onItemEnd(name);\n            entry.header.offset = dindex; // data header\n\n            var dataHeader = entry.header.dataHeaderToBinary();\n            var postHeader = new Buffer(name);\n            var dataLength = dataHeader.length + postHeader.length + compressedData.length;\n            dindex += dataLength;\n            dataBlock.push(dataHeader);\n            dataBlock.push(postHeader);\n            dataBlock.push(compressedData);\n            var entryHeader = entry.packHeader();\n            entryHeaders.push(entryHeader);\n            mainHeader.size += entryHeader.length;\n            totalSize += dataLength + entryHeader.length;\n\n            if (entryList.length) {\n              self(entryList);\n            } else {\n              totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n              // point to end of data and begining of central directory first record\n\n              mainHeader.offset = dindex;\n              dindex = 0;\n              var outBuffer = new Buffer(totalSize);\n              dataBlock.forEach(function (content) {\n                content.copy(outBuffer, dindex); // write data blocks\n\n                dindex += content.length;\n              });\n              entryHeaders.forEach(function (content) {\n                content.copy(outBuffer, dindex); // write central directory entries\n\n                dindex += content.length;\n              });\n              var mh = mainHeader.toBinary();\n\n              if (_comment) {\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n\n              }\n\n              mh.copy(outBuffer, dindex); // write main header\n\n              onSuccess(outBuffer);\n            }\n          });\n        }\n      };\n\n      compress(entryList);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}