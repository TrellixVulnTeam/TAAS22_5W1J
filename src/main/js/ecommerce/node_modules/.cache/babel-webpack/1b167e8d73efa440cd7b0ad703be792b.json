{"ast":null,"code":"/*!\n * Tmp\n *\n * Copyright (c) 2011-2013 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar fs = require('fs'),\n    path = require('path'),\n    os = require('os'),\n    exists = fs.exists || path.exists,\n    tmpDir = os.tmpDir || _getTMPDir,\n    _c = require('constants');\n/**\n * The working inner variables.\n */\n\n\nvar // store the actual TMP directory\n_TMP = tmpDir(),\n    // the random characters to choose from\nrandomChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\",\n    randomCharsLength = randomChars.length,\n    // this will hold the objects need to be removed on exit\n_removeObjects = [],\n    _gracefulCleanup = false,\n    _uncaughtException = false;\n/**\n * Gets the temp directory.\n *\n * @return {String}\n * @api private\n */\n\n\nfunction _getTMPDir() {\n  var tmpNames = ['TMPDIR', 'TMP', 'TEMP'];\n\n  for (var i = 0, length = tmpNames.length; i < length; i++) {\n    if (_isUndefined(process.env[tmpNames[i]])) continue;\n    return process.env[tmpNames[i]];\n  } // fallback to the default\n\n\n  return '/tmp';\n}\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\n\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api private\n */\n\n\nfunction _parseArguments(options, callback) {\n  if (!callback || typeof callback != \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  return [options, callback];\n}\n/**\n * Gets a temporary file name.\n *\n * @param {Object} opts\n * @param {Function} cb\n * @api private\n */\n\n\nfunction _getTmpName(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1],\n      template = opts.template,\n      templateDefined = !_isUndefined(template),\n      tries = opts.tries || 3;\n\n  if (isNaN(tries) || tries < 0) return cb(new Error('Invalid tries'));\n  if (templateDefined && !template.match(/XXXXXX/)) return cb(new Error('Invalid template provided'));\n\n  function _getName() {\n    // prefix and postfix\n    if (!templateDefined) {\n      var name = [_isUndefined(opts.prefix) ? 'tmp-' : opts.prefix, process.pid, (Math.random() * 0x1000000000).toString(36), opts.postfix].join('');\n      return path.join(opts.dir || _TMP, name);\n    } // mkstemps like template\n\n\n    var chars = [];\n\n    for (var i = 0; i < 6; i++) {\n      chars.push(randomChars.substr(Math.floor(Math.random() * randomCharsLength), 1));\n    }\n\n    return template.replace(/XXXXXX/, chars.join(''));\n  }\n\n  (function _getUniqueName() {\n    var name = _getName(); // check whether the path exists then retry if needed\n\n\n    exists(name, function _pathExists(pathExists) {\n      if (pathExists) {\n        if (tries-- > 0) return _getUniqueName();\n        return cb(new Error('Could not get a unique tmp filename, max tries reached'));\n      }\n\n      cb(null, name);\n    });\n  })();\n}\n/**\n * Creates and opens a temporary file.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\n\n\nfunction _createTmpFile(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1];\n\n  opts.postfix = _isUndefined(opts.postfix) ? '.tmp' : opts.postfix; // gets a temporary filename\n\n  _getTmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err); // create and open the file\n\n    fs.open(name, _c.O_CREAT | _c.O_EXCL | _c.O_RDWR, opts.mode || 0600, function _fileCreated(err, fd) {\n      if (err) return cb(err);\n\n      var removeCallback = _prepareRemoveCallback(fs.unlinkSync.bind(fs), name);\n\n      if (!opts.keep) {\n        _removeObjects.unshift(removeCallback);\n      }\n\n      cb(null, name, fd, removeCallback);\n    });\n  });\n}\n/**\n * Removes files and folders in a directory recursively.\n *\n * @param {String} dir\n */\n\n\nfunction _rmdirRecursiveSync(dir) {\n  var files = fs.readdirSync(dir);\n\n  for (var i = 0, length = files.length; i < length; i++) {\n    var file = path.join(dir, files[i]); // lstat so we don't recurse into symlinked directories.\n\n    var stat = fs.lstatSync(file);\n\n    if (stat.isDirectory()) {\n      _rmdirRecursiveSync(file);\n    } else {\n      fs.unlinkSync(file);\n    }\n  }\n\n  fs.rmdirSync(dir);\n}\n/**\n *\n * @param {Function} removeFunction\n * @param {String} path\n * @returns {Function}\n * @private\n */\n\n\nfunction _prepareRemoveCallback(removeFunction, path) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n\n    removeFunction(path);\n    called = true;\n  };\n}\n/**\n * Creates a temporary directory.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\n\n\nfunction _createTmpDir(options, callback) {\n  var args = _parseArguments(options, callback),\n      opts = args[0],\n      cb = args[1]; // gets a temporary filename\n\n\n  _getTmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err); // create the directory\n\n    fs.mkdir(name, opts.mode || 0700, function _dirCreated(err) {\n      if (err) return cb(err);\n\n      var removeCallback = _prepareRemoveCallback(opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs), name);\n\n      if (!opts.keep) {\n        _removeObjects.unshift(removeCallback);\n      }\n\n      cb(null, name, removeCallback);\n    });\n  });\n}\n/**\n * The garbage collector.\n *\n * @api private\n */\n\n\nfunction _garbageCollector() {\n  if (_uncaughtException && !_gracefulCleanup) {\n    return;\n  }\n\n  for (var i = 0, length = _removeObjects.length; i < length; i++) {\n    try {\n      _removeObjects[i].call(null);\n    } catch (e) {// already removed?\n    }\n  }\n}\n\nfunction _setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\nvar version = process.versions.node.split('.').map(function (value) {\n  return parseInt(value, 10);\n});\n\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {\n    _uncaughtException = true;\n\n    _garbageCollector();\n\n    throw err;\n  });\n}\n\nprocess.addListener('exit', function _exit(code) {\n  if (code) _uncaughtException = true;\n\n  _garbageCollector();\n}); // exporting all the needed methods\n\nmodule.exports.tmpdir = _TMP;\nmodule.exports.dir = _createTmpDir;\nmodule.exports.file = _createTmpFile;\nmodule.exports.tmpName = _getTmpName;\nmodule.exports.setGracefulCleanup = _setGracefulCleanup;","map":null,"metadata":{},"sourceType":"script"}