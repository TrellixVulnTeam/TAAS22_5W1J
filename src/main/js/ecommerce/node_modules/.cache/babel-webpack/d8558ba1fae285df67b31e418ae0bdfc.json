{"ast":null,"code":"var Utils = require(\"./util\"),\n    Headers = require(\"./headers\"),\n    Constants = Utils.Constants,\n    Methods = require(\"./methods\");\n\nmodule.exports = function (\n/*Buffer*/\ninput) {\n  var _entryHeader = new Headers.EntryHeader(),\n      _entryName = new Buffer(0),\n      _comment = new Buffer(0),\n      _isDirectory = false,\n      uncompressedData = null,\n      _extra = new Buffer(0);\n\n  function getCompressedDataFromZip() {\n    if (!input || !Buffer.isBuffer(input)) {\n      return new Buffer(0);\n    }\n\n    _entryHeader.loadDataHeaderFromBinary(input);\n\n    return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);\n  }\n\n  function crc32OK(data) {\n    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n    if (_entryHeader.flags & 0x8 != 0x8) {\n      if (Utils.crc32(data) != _entryHeader.crc) {\n        return false;\n      }\n    } else {// @TODO: load and check data descriptor header\n      // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\n      // (optionally preceded by a 4-byte signature) immediately after the compressed data:\n    }\n\n    return true;\n  }\n\n  function decompress(\n  /*Boolean*/\n  async,\n  /*Function*/\n  callback) {\n    if (_isDirectory) {\n      if (async && callback) {\n        callback(new Buffer(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\n      }\n\n      return new Buffer(0);\n    }\n\n    var compressedData = getCompressedDataFromZip();\n\n    if (compressedData.length == 0) {\n      if (async && callback) callback(compressedData, Utils.Errors.NO_DATA); //si added error.\n\n      return compressedData;\n    }\n\n    var data = new Buffer(_entryHeader.size);\n    data.fill(0);\n\n    switch (_entryHeader.method) {\n      case Utils.Constants.STORED:\n        compressedData.copy(data);\n\n        if (!crc32OK(data)) {\n          if (async && callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n\n          return Utils.Errors.BAD_CRC;\n        } else {\n          //si added otherwise did not seem to return data.\n          if (async && callback) callback(data);\n          return data;\n        }\n\n        break;\n\n      case Utils.Constants.DEFLATED:\n        var inflater = new Methods.Inflater(compressedData);\n\n        if (!async) {\n          inflater.inflate(data);\n\n          if (!crc32OK(data)) {\n            console.warn(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\n          }\n\n          return data;\n        } else {\n          inflater.inflateAsync(function (result) {\n            result.copy(data, 0);\n\n            if (crc32OK(data)) {\n              if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n            } else {\n              //si added otherwise did not seem to return data.\n              if (callback) callback(data);\n            }\n          });\n        }\n\n        break;\n\n      default:\n        if (async && callback) callback(new Buffer(0), Utils.Errors.UNKNOWN_METHOD);\n        return Utils.Errors.UNKNOWN_METHOD;\n    }\n  }\n\n  function compress(\n  /*Boolean*/\n  async,\n  /*Function*/\n  callback) {\n    if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n      // no data set or the data wasn't changed to require recompression\n      if (async && callback) callback(getCompressedDataFromZip());\n      return getCompressedDataFromZip();\n    }\n\n    if (uncompressedData.length && !_isDirectory) {\n      var compressedData; // Local file header\n\n      switch (_entryHeader.method) {\n        case Utils.Constants.STORED:\n          _entryHeader.compressedSize = _entryHeader.size;\n          compressedData = new Buffer(uncompressedData.length);\n          uncompressedData.copy(compressedData);\n          if (async && callback) callback(compressedData);\n          return compressedData;\n          break;\n\n        default:\n        case Utils.Constants.DEFLATED:\n          var deflater = new Methods.Deflater(uncompressedData);\n\n          if (!async) {\n            var deflated = deflater.deflate();\n            _entryHeader.compressedSize = deflated.length;\n            return deflated;\n          } else {\n            deflater.deflateAsync(function (data) {\n              compressedData = new Buffer(data.length);\n              _entryHeader.compressedSize = data.length;\n              data.copy(compressedData);\n              callback && callback(compressedData);\n            });\n          }\n\n          deflater = null;\n          break;\n      }\n    } else {\n      if (async && callback) {\n        callback(new Buffer(0));\n      } else {\n        return new Buffer(0);\n      }\n    }\n  }\n\n  return {\n    get entryName() {\n      return _entryName.toString();\n    },\n\n    get rawEntryName() {\n      return _entryName;\n    },\n\n    set entryName(val) {\n      _entryName = Utils.toBuffer(val);\n      var lastChar = _entryName[_entryName.length - 1];\n      _isDirectory = lastChar == 47 || lastChar == 92;\n      _entryHeader.fileNameLength = _entryName.length;\n    },\n\n    get extra() {\n      return _extra;\n    },\n\n    set extra(val) {\n      _extra = val;\n      _entryHeader.extraLength = val.length;\n    },\n\n    get comment() {\n      return _comment.toString();\n    },\n\n    set comment(val) {\n      _comment = Utils.toBuffer(val);\n      _entryHeader.commentLength = _comment.length;\n    },\n\n    get name() {\n      var n = _entryName.toString();\n\n      return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop();\n    },\n\n    get isDirectory() {\n      return _isDirectory;\n    },\n\n    getCompressedData: function getCompressedData() {\n      return compress(false, null);\n    },\n    getCompressedDataAsync: function getCompressedDataAsync(\n    /*Function*/\n    callback) {\n      compress(true, callback);\n    },\n    setData: function setData(value) {\n      uncompressedData = Utils.toBuffer(value);\n\n      if (!_isDirectory && uncompressedData.length) {\n        _entryHeader.size = uncompressedData.length;\n        _entryHeader.method = Utils.Constants.DEFLATED;\n        _entryHeader.crc = Utils.crc32(value);\n      } else {\n        // folders and blank files should be stored\n        _entryHeader.method = Utils.Constants.STORED;\n      }\n    },\n    getData: function getData() {\n      return decompress(false, null);\n    },\n    getDataAsync: function getDataAsync(\n    /*Function*/\n    callback) {\n      decompress(true, callback);\n    },\n\n    set header(\n    /*Buffer*/\n    data) {\n      _entryHeader.loadFromBinary(data);\n    },\n\n    get header() {\n      return _entryHeader;\n    },\n\n    packHeader: function packHeader() {\n      var header = _entryHeader.entryHeaderToBinary(); // add\n\n\n      _entryName.copy(header, Utils.Constants.CENHDR);\n\n      if (_entryHeader.extraLength) {\n        _extra.copy(header, Utils.Constants.CENHDR + _entryName.length);\n      }\n\n      if (_entryHeader.commentLength) {\n        _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);\n      }\n\n      return header;\n    },\n    toString: function toString() {\n      return '{\\n' + '\\t\"entryName\" : \"' + _entryName.toString() + \"\\\",\\n\" + '\\t\"name\" : \"' + _entryName.toString().split(\"/\").pop() + \"\\\",\\n\" + '\\t\"comment\" : \"' + _comment.toString() + \"\\\",\\n\" + '\\t\"isDirectory\" : ' + _isDirectory + \",\\n\" + '\\t\"header\" : ' + _entryHeader.toString().replace(/\\t/mg, \"\\t\\t\") + \",\\n\" + '\\t\"compressedData\" : <' + (input && input.length + \" bytes buffer\" || \"null\") + \">\\n\" + '\\t\"data\" : <' + (uncompressedData && uncompressedData.length + \" bytes buffer\" || \"null\") + \">\\n\" + '}';\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}