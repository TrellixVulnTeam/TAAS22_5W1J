{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/**\n * @fileoverview The heart of the WebDriver JavaScript API.\n */\n'use strict';\n\nvar _defineProperty = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/defineProperty\").default;\n\nvar _createForOfIteratorHelper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\").default;\n\nvar _inherits = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _actions = require('./actions');\n\nvar by = require('./by');\n\nvar Capabilities = require('./capabilities').Capabilities;\n\nvar command = require('./command');\n\nvar error = require('./error');\n\nvar input = require('./input');\n\nvar logging = require('./logging');\n\nvar Session = require('./session').Session;\n\nvar Symbols = require('./symbols');\n\nvar promise = require('./promise');\n/**\n * Defines a condition for use with WebDriver's {@linkplain WebDriver#wait wait\n * command}.\n *\n * @template OUT\n */\n\n\nvar Condition = /*#__PURE__*/function () {\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): OUT} fn The condition function to\n   *     evaluate on each iteration of the wait loop.\n   */\n  function Condition(message, fn) {\n    _classCallCheck(this, Condition);\n\n    /** @private {string} */\n    this.description_ = 'Waiting ' + message;\n    /** @type {function(!WebDriver): OUT} */\n\n    this.fn = fn;\n  }\n  /** @return {string} A description of this condition. */\n\n\n  _createClass(Condition, [{\n    key: \"description\",\n    value: function description() {\n      return this.description_;\n    }\n  }]);\n\n  return Condition;\n}();\n/**\n * Defines a condition that will result in a {@link WebElement}.\n *\n * @extends {Condition<!(WebElement|promise.Promise<!WebElement>)>}\n */\n\n\nvar WebElementCondition = /*#__PURE__*/function (_Condition) {\n  _inherits(WebElementCondition, _Condition);\n\n  var _super = _createSuper(WebElementCondition);\n\n  /**\n   * @param {string} message A descriptive error message. Should complete the\n   *     sentence \"Waiting [...]\"\n   * @param {function(!WebDriver): !(WebElement|promise.Promise<!WebElement>)}\n   *     fn The condition function to evaluate on each iteration of the wait\n   *     loop.\n   */\n  function WebElementCondition(message, fn) {\n    _classCallCheck(this, WebElementCondition);\n\n    return _super.call(this, message, fn);\n  }\n\n  return WebElementCondition;\n}(Condition); //////////////////////////////////////////////////////////////////////////////\n//\n//  WebDriver\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Translates a command to its wire-protocol representation before passing it\n * to the given `executor` for execution.\n * @param {!command.Executor} executor The executor to use.\n * @param {!command.Command} command The command to execute.\n * @return {!promise.Promise} A promise that will resolve with the\n *     command response.\n */\n\n\nfunction executeCommand(executor, command) {\n  return toWireValue(command.getParameters()).then(function (parameters) {\n    command.setParameters(parameters);\n    return executor.execute(command);\n  });\n}\n/**\n * Converts an object to its JSON representation in the WebDriver wire protocol.\n * When converting values of type object, the following steps will be taken:\n * <ol>\n * <li>if the object is a WebElement, the return value will be the element's\n *     server ID\n * <li>if the object defines a {@link Symbols.serialize} method, this algorithm\n *     will be recursively applied to the object's serialized representation\n * <li>if the object provides a \"toJSON\" function, this algorithm will\n *     recursively be applied to the result of that function\n * <li>otherwise, the value of each key will be recursively converted according\n *     to the rules above.\n * </ol>\n *\n * @param {*} obj The object to convert.\n * @return {!promise.Promise<?>} A promise that will resolve to the\n *     input value's JSON representation.\n */\n\n\nfunction toWireValue(obj) {\n  if (promise.isPromise(obj)) {\n    return obj.then(toWireValue);\n  }\n\n  return promise.fulfilled(convertValue(obj));\n}\n\nfunction convertValue(value) {\n  if (value === void 0 || value === null) {\n    return value;\n  }\n\n  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return convertKeys(value);\n  }\n\n  if (typeof value === 'function') {\n    return '' + value;\n  }\n\n  if (typeof value[Symbols.serialize] === 'function') {\n    return toWireValue(value[Symbols.serialize]());\n  } else if (typeof value.toJSON === 'function') {\n    return toWireValue(value.toJSON());\n  }\n\n  return convertKeys(value);\n}\n\nfunction convertKeys(obj) {\n  var isArray = Array.isArray(obj);\n  var numKeys = isArray ? obj.length : Object.keys(obj).length;\n  var ret = isArray ? new Array(numKeys) : {};\n\n  if (!numKeys) {\n    return promise.fulfilled(ret);\n  }\n\n  var numResolved = 0;\n\n  function forEachKey(obj, fn) {\n    if (Array.isArray(obj)) {\n      for (var i = 0, n = obj.length; i < n; i++) {\n        fn(obj[i], i);\n      }\n    } else {\n      for (var key in obj) {\n        fn(obj[key], key);\n      }\n    }\n  }\n\n  return new promise.Promise(function (done, reject) {\n    forEachKey(obj, function (value, key) {\n      if (promise.isPromise(value)) {\n        value.then(toWireValue).then(setValue, reject);\n      } else {\n        value = convertValue(value);\n\n        if (promise.isPromise(value)) {\n          value.then(toWireValue).then(setValue, reject);\n        } else {\n          setValue(value);\n        }\n      }\n\n      function setValue(value) {\n        ret[key] = value;\n        maybeFulfill();\n      }\n    });\n\n    function maybeFulfill() {\n      if (++numResolved === numKeys) {\n        done(ret);\n      }\n    }\n  });\n}\n/**\n * Converts a value from its JSON representation according to the WebDriver wire\n * protocol. Any JSON object that defines a WebElement ID will be decoded to a\n * {@link WebElement} object. All other values will be passed through as is.\n *\n * @param {!WebDriver} driver The driver to use as the parent of any unwrapped\n *     {@link WebElement} values.\n * @param {*} value The value to convert.\n * @return {*} The converted value.\n */\n\n\nfunction fromWireValue(driver, value) {\n  if (Array.isArray(value)) {\n    value = value.map(function (v) {\n      return fromWireValue(driver, v);\n    });\n  } else if (WebElement.isId(value)) {\n    var id = WebElement.extractId(value);\n    value = new WebElement(driver, id);\n  } else if (value && typeof value === 'object') {\n    var result = {};\n\n    for (var key in value) {\n      if (value.hasOwnProperty(key)) {\n        result[key] = fromWireValue(driver, value[key]);\n      }\n    }\n\n    value = result;\n  }\n\n  return value;\n}\n/**\n * Creates a new WebDriver client, which provides control over a browser.\n *\n * Every command.Command returns a {@link promise.Promise} that\n * represents the result of that command. Callbacks may be registered on this\n * object to manipulate the command result or catch an expected error. Any\n * commands scheduled with a callback are considered sub-commands and will\n * execute before the next command in the current frame. For example:\n *\n *     var message = [];\n *     driver.call(message.push, message, 'a').then(function() {\n *       driver.call(message.push, message, 'b');\n *     });\n *     driver.call(message.push, message, 'c');\n *     driver.call(function() {\n *       alert('message is abc? ' + (message.join('') == 'abc'));\n *     });\n *\n */\n\n\nvar WebDriver = /*#__PURE__*/function () {\n  /**\n   * @param {!(Session|promise.Promise<!Session>)} session Either a\n   *     known session or a promise that will be resolved to a session.\n   * @param {!command.Executor} executor The executor to use when sending\n   *     commands to the browser.\n   * @param {promise.ControlFlow=} opt_flow The flow to\n   *     schedule commands through. Defaults to the active flow object.\n   */\n  function WebDriver(session, executor, opt_flow) {\n    _classCallCheck(this, WebDriver);\n\n    /** @private {!promise.Promise<!Session>} */\n    this.session_ = promise.fulfilled(session);\n    ;\n    /** @private {!command.Executor} */\n\n    this.executor_ = executor;\n    /** @private {!promise.ControlFlow} */\n\n    this.flow_ = opt_flow || promise.controlFlow();\n    /** @private {input.FileDetector} */\n\n    this.fileDetector_ = null;\n  }\n  /**\n   * Creates a new WebDriver client for an existing session.\n   * @param {!command.Executor} executor Command executor to use when querying\n   *     for session details.\n   * @param {string} sessionId ID of the session to attach to.\n   * @param {promise.ControlFlow=} opt_flow The control flow all\n   *     driver commands should execute under. Defaults to the\n   *     {@link promise.controlFlow() currently active}  control flow.\n   * @return {!WebDriver} A new client for the specified session.\n   */\n\n\n  _createClass(WebDriver, [{\n    key: \"controlFlow\",\n    value:\n    /**\n     * @return {!promise.ControlFlow} The control flow used by this\n     *     instance.\n     */\n    function controlFlow() {\n      return this.flow_;\n    }\n    /**\n     * Schedules a {@link command.Command} to be executed by this driver's\n     * {@link command.Executor}.\n     *\n     * @param {!command.Command} command The command to schedule.\n     * @param {string} description A description of the command for debugging.\n     * @return {!promise.Promise<T>} A promise that will be resolved\n     *     with the command result.\n     * @template T\n     */\n\n  }, {\n    key: \"schedule\",\n    value: function schedule(command, description) {\n      var self = this;\n      checkHasNotQuit();\n      command.setParameter('sessionId', this.session_); // If any of the command parameters are rejected promises, those\n      // rejections may be reported as unhandled before the control flow\n      // attempts to execute the command. To ensure parameters errors\n      // propagate through the command itself, we resolve all of the\n      // command parameters now, but suppress any errors until the ControlFlow\n      // actually executes the command. This addresses scenarios like catching\n      // an element not found error in:\n      //\n      //     driver.findElement(By.id('foo')).click().catch(function(e) {\n      //       if (e instanceof NoSuchElementError) {\n      //         // Do something.\n      //       }\n      //     });\n\n      var prepCommand = toWireValue(command.getParameters());\n      prepCommand.catch(function () {});\n      var flow = this.flow_;\n      var executor = this.executor_;\n      return flow.execute(function () {\n        // A call to WebDriver.quit() may have been scheduled in the same event\n        // loop as this |command|, which would prevent us from detecting that the\n        // driver has quit above.  Therefore, we need to make another quick check.\n        // We still check above so we can fail as early as possible.\n        checkHasNotQuit(); // Retrieve resolved command parameters; any previously suppressed errors\n        // will now propagate up through the control flow as part of the command\n        // execution.\n\n        return prepCommand.then(function (parameters) {\n          command.setParameters(parameters);\n          return executor.execute(command);\n        }).then(function (value) {\n          return fromWireValue(self, value);\n        });\n      }, description);\n\n      function checkHasNotQuit() {\n        if (!self.session_) {\n          throw new error.NoSuchSessionError('This driver instance does not have a valid session ID ' + '(did you call WebDriver.quit()?) and may no longer be ' + 'used.');\n        }\n      }\n    }\n    /**\n     * Sets the {@linkplain input.FileDetector file detector} that should be\n     * used with this instance.\n     * @param {input.FileDetector} detector The detector to use or {@code null}.\n     */\n\n  }, {\n    key: \"setFileDetector\",\n    value: function setFileDetector(detector) {\n      this.fileDetector_ = detector;\n    }\n    /**\n     * @return {!command.Executor} The command executor used by this instance.\n     */\n\n  }, {\n    key: \"getExecutor\",\n    value: function getExecutor() {\n      return this.executor_;\n    }\n    /**\n     * @return {!promise.Promise<!Session>} A promise for this client's\n     *     session.\n     */\n\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return this.session_;\n    }\n    /**\n     * @return {!promise.Promise<!Capabilities>} A promise\n     *     that will resolve with the this instance's capabilities.\n     */\n\n  }, {\n    key: \"getCapabilities\",\n    value: function getCapabilities() {\n      return this.session_.then(function (session) {\n        return session.getCapabilities();\n      });\n    }\n    /**\n     * Schedules a command to quit the current session. After calling quit, this\n     * instance will be invalidated and may no longer be used to issue commands\n     * against the browser.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the command has completed.\n     */\n\n  }, {\n    key: \"quit\",\n    value: function quit() {\n      var _this = this;\n\n      var result = this.schedule(new command.Command(command.Name.QUIT), 'WebDriver.quit()'); // Delete our session ID when the quit command finishes; this will allow us\n      // to throw an error when attemnpting to use a driver post-quit.\n\n      return result.finally(function () {\n        return delete _this.session_;\n      });\n    }\n    /**\n     * Creates a new action sequence using this driver. The sequence will not be\n     * scheduled for execution until {@link actions.ActionSequence#perform} is\n     * called. Example:\n     *\n     *     driver.actions().\n     *         mouseDown(element1).\n     *         mouseMove(element2).\n     *         mouseUp().\n     *         perform();\n     *\n     * @return {!actions.ActionSequence} A new action sequence for this instance.\n     */\n\n  }, {\n    key: \"actions\",\n    value: function actions() {\n      return new _actions.ActionSequence(this);\n    }\n    /**\n     * Creates a new touch sequence using this driver. The sequence will not be\n     * scheduled for execution until {@link actions.TouchSequence#perform} is\n     * called. Example:\n     *\n     *     driver.touchActions().\n     *         tap(element1).\n     *         doubleTap(element2).\n     *         perform();\n     *\n     * @return {!actions.TouchSequence} A new touch sequence for this instance.\n     */\n\n  }, {\n    key: \"touchActions\",\n    value: function touchActions() {\n      return new _actions.TouchSequence(this);\n    }\n    /**\n     * Schedules a command to execute JavaScript in the context of the currently\n     * selected frame or window. The script fragment will be executed as the body\n     * of an anonymous function. If the script is provided as a function object,\n     * that function will be converted to a string for injection into the target\n     * window.\n     *\n     * Any arguments provided in addition to the script will be included as script\n     * arguments and may be referenced using the {@code arguments} object.\n     * Arguments may be a boolean, number, string, or {@linkplain WebElement}.\n     * Arrays and objects may also be used as script arguments as long as each item\n     * adheres to the types previously mentioned.\n     *\n     * The script may refer to any variables accessible from the current window.\n     * Furthermore, the script will execute in the window's context, thus\n     * {@code document} may be used to refer to the current document. Any local\n     * variables will not be available once the script has finished executing,\n     * though global variables will persist.\n     *\n     * If the script has a return value (i.e. if the script contains a return\n     * statement), then the following steps will be taken for resolving this\n     * functions return value:\n     *\n     * - For a HTML element, the value will resolve to a {@linkplain WebElement}\n     * - Null and undefined return values will resolve to null</li>\n     * - Booleans, numbers, and strings will resolve as is</li>\n     * - Functions will resolve to their string representation</li>\n     * - For arrays and objects, each member item will be converted according to\n     *     the rules above\n     *\n     * @param {!(string|Function)} script The script to execute.\n     * @param {...*} var_args The arguments to pass to the script.\n     * @return {!promise.Promise<T>} A promise that will resolve to the\n     *    scripts return value.\n     * @template T\n     */\n\n  }, {\n    key: \"executeScript\",\n    value: function executeScript(script, var_args) {\n      if (typeof script === 'function') {\n        script = 'return (' + script + ').apply(null, arguments);';\n      }\n\n      var args = arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : [];\n      return this.schedule(new command.Command(command.Name.EXECUTE_SCRIPT).setParameter('script', script).setParameter('args', args), 'WebDriver.executeScript()');\n    }\n    /**\n     * Schedules a command to execute asynchronous JavaScript in the context of the\n     * currently selected frame or window. The script fragment will be executed as\n     * the body of an anonymous function. If the script is provided as a function\n     * object, that function will be converted to a string for injection into the\n     * target window.\n     *\n     * Any arguments provided in addition to the script will be included as script\n     * arguments and may be referenced using the {@code arguments} object.\n     * Arguments may be a boolean, number, string, or {@code WebElement}.\n     * Arrays and objects may also be used as script arguments as long as each item\n     * adheres to the types previously mentioned.\n     *\n     * Unlike executing synchronous JavaScript with {@link #executeScript},\n     * scripts executed with this function must explicitly signal they are finished\n     * by invoking the provided callback. This callback will always be injected\n     * into the executed function as the last argument, and thus may be referenced\n     * with {@code arguments[arguments.length - 1]}. The following steps will be\n     * taken for resolving this functions return value against the first argument\n     * to the script's callback function:\n     *\n     * - For a HTML element, the value will resolve to a\n     *     {@link WebElement}\n     * - Null and undefined return values will resolve to null\n     * - Booleans, numbers, and strings will resolve as is\n     * - Functions will resolve to their string representation\n     * - For arrays and objects, each member item will be converted according to\n     *     the rules above\n     *\n     * __Example #1:__ Performing a sleep that is synchronized with the currently\n     * selected window:\n     *\n     *     var start = new Date().getTime();\n     *     driver.executeAsyncScript(\n     *         'window.setTimeout(arguments[arguments.length - 1], 500);').\n     *         then(function() {\n     *           console.log(\n     *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');\n     *         });\n     *\n     * __Example #2:__ Synchronizing a test with an AJAX application:\n     *\n     *     var button = driver.findElement(By.id('compose-button'));\n     *     button.click();\n     *     driver.executeAsyncScript(\n     *         'var callback = arguments[arguments.length - 1];' +\n     *         'mailClient.getComposeWindowWidget().onload(callback);');\n     *     driver.switchTo().frame('composeWidget');\n     *     driver.findElement(By.id('to')).sendKeys('dog@example.com');\n     *\n     * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In\n     * this example, the inject script is specified with a function literal. When\n     * using this format, the function is converted to a string for injection, so it\n     * should not reference any symbols not defined in the scope of the page under\n     * test.\n     *\n     *     driver.executeAsyncScript(function() {\n     *       var callback = arguments[arguments.length - 1];\n     *       var xhr = new XMLHttpRequest();\n     *       xhr.open(\"GET\", \"/resource/data.json\", true);\n     *       xhr.onreadystatechange = function() {\n     *         if (xhr.readyState == 4) {\n     *           callback(xhr.responseText);\n     *         }\n     *       };\n     *       xhr.send('');\n     *     }).then(function(str) {\n     *       console.log(JSON.parse(str)['food']);\n     *     });\n     *\n     * @param {!(string|Function)} script The script to execute.\n     * @param {...*} var_args The arguments to pass to the script.\n     * @return {!promise.Promise<T>} A promise that will resolve to the\n     *    scripts return value.\n     * @template T\n     */\n\n  }, {\n    key: \"executeAsyncScript\",\n    value: function executeAsyncScript(script, var_args) {\n      if (typeof script === 'function') {\n        script = 'return (' + script + ').apply(null, arguments);';\n      }\n\n      var args = Array.prototype.slice.call(arguments, 1);\n      return this.schedule(new command.Command(command.Name.EXECUTE_ASYNC_SCRIPT).setParameter('script', script).setParameter('args', args), 'WebDriver.executeScript()');\n    }\n    /**\n     * Schedules a command to execute a custom function.\n     * @param {function(...): (T|promise.Promise<T>)} fn The function to\n     *     execute.\n     * @param {Object=} opt_scope The object in whose scope to execute the function.\n     * @param {...*} var_args Any arguments to pass to the function.\n     * @return {!promise.Promise<T>} A promise that will be resolved'\n     *     with the function's result.\n     * @template T\n     */\n\n  }, {\n    key: \"call\",\n    value: function call(fn, opt_scope, var_args) {\n      var args = Array.prototype.slice.call(arguments, 2);\n      var flow = this.flow_;\n      return flow.execute(function () {\n        return promise.fullyResolved(args).then(function (args) {\n          if (promise.isGenerator(fn)) {\n            args.unshift(fn, opt_scope);\n            return promise.consume.apply(null, args);\n          }\n\n          return fn.apply(opt_scope, args);\n        });\n      }, 'WebDriver.call(' + (fn.name || 'function') + ')');\n    }\n    /**\n     * Schedules a command to wait for a condition to hold. The condition may be\n     * specified by a {@link Condition}, as a custom function, or as any\n     * promise-like thenable.\n     *\n     * For a {@link Condition} or function, the wait will repeatedly\n     * evaluate the condition until it returns a truthy value. If any errors occur\n     * while evaluating the condition, they will be allowed to propagate. In the\n     * event a condition returns a {@link promise.Promise promise}, the polling\n     * loop will wait for it to be resolved and use the resolved value for whether\n     * the condition has been satisified. Note the resolution time for a promise\n     * is factored into whether a wait has timed out.\n     *\n     * Note, if the provided condition is a {@link WebElementCondition}, then\n     * the wait will return a {@link WebElementPromise} that will resolve to the\n     * element that satisified the condition.\n     *\n     * _Example:_ waiting up to 10 seconds for an element to be present on the\n     * page.\n     *\n     *     var button = driver.wait(until.elementLocated(By.id('foo')), 10000);\n     *     button.click();\n     *\n     * This function may also be used to block the command flow on the resolution\n     * of any thenable promise object. When given a promise, the command will\n     * simply wait for its resolution before completing. A timeout may be provided\n     * to fail the command if the promise does not resolve before the timeout\n     * expires.\n     *\n     * _Example:_ Suppose you have a function, `startTestServer`, that returns a\n     * promise for when a server is ready for requests. You can block a WebDriver\n     * client on this promise with:\n     *\n     *     var started = startTestServer();\n     *     driver.wait(started, 5 * 1000, 'Server should start within 5 seconds');\n     *     driver.get(getServerUrl());\n     *\n     * @param {!(promise.Promise<T>|\n     *           Condition<T>|\n     *           function(!WebDriver): T)} condition The condition to\n     *     wait on, defined as a promise, condition object, or  a function to\n     *     evaluate as a condition.\n     * @param {number=} opt_timeout How long to wait for the condition to be true.\n     * @param {string=} opt_message An optional message to use if the wait times\n     *     out.\n     * @return {!(promise.Promise<T>|WebElementPromise)} A promise that will be\n     *     resolved with the first truthy value returned by the condition\n     *     function, or rejected if the condition times out. If the input\n     *     input condition is an instance of a {@link WebElementCondition},\n     *     the returned value will be a {@link WebElementPromise}.\n     * @template T\n     */\n\n  }, {\n    key: \"wait\",\n    value: function wait(condition, opt_timeout, opt_message) {\n      if (promise.isPromise(condition)) {\n        return this.flow_.wait(\n        /** @type {!promise.Promise} */\n        condition, opt_timeout, opt_message);\n      }\n\n      var message = opt_message;\n      var fn =\n      /** @type {!Function} */\n      condition;\n\n      if (condition instanceof Condition) {\n        message = message || condition.description();\n        fn = condition.fn;\n      }\n\n      var driver = this;\n      var result = this.flow_.wait(function () {\n        if (promise.isGenerator(fn)) {\n          return promise.consume(fn, null, [driver]);\n        }\n\n        return fn(driver);\n      }, opt_timeout, message);\n\n      if (condition instanceof WebElementCondition) {\n        result = new WebElementPromise(this, result.then(function (value) {\n          if (!(value instanceof WebElement)) {\n            throw TypeError('WebElementCondition did not resolve to a WebElement: ' + Object.prototype.toString.call(value));\n          }\n\n          return value;\n        }));\n      }\n\n      return result;\n    }\n    /**\n     * Schedules a command to make the driver sleep for the given amount of time.\n     * @param {number} ms The amount of time, in milliseconds, to sleep.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the sleep has finished.\n     */\n\n  }, {\n    key: \"sleep\",\n    value: function sleep(ms) {\n      return this.flow_.timeout(ms, 'WebDriver.sleep(' + ms + ')');\n    }\n    /**\n     * Schedules a command to retrieve they current window handle.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the current window handle.\n     */\n\n  }, {\n    key: \"getWindowHandle\",\n    value: function getWindowHandle() {\n      return this.schedule(new command.Command(command.Name.GET_CURRENT_WINDOW_HANDLE), 'WebDriver.getWindowHandle()');\n    }\n    /**\n     * Schedules a command to retrieve the current list of available window handles.\n     * @return {!promise.Promise.<!Array<string>>} A promise that will\n     *     be resolved with an array of window handles.\n     */\n\n  }, {\n    key: \"getAllWindowHandles\",\n    value: function getAllWindowHandles() {\n      return this.schedule(new command.Command(command.Name.GET_WINDOW_HANDLES), 'WebDriver.getAllWindowHandles()');\n    }\n    /**\n     * Schedules a command to retrieve the current page's source. The page source\n     * returned is a representation of the underlying DOM: do not expect it to be\n     * formatted or escaped in the same way as the response sent from the web\n     * server.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the current page source.\n     */\n\n  }, {\n    key: \"getPageSource\",\n    value: function getPageSource() {\n      return this.schedule(new command.Command(command.Name.GET_PAGE_SOURCE), 'WebDriver.getPageSource()');\n    }\n    /**\n     * Schedules a command to close the current window.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when this command has completed.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return this.schedule(new command.Command(command.Name.CLOSE), 'WebDriver.close()');\n    }\n    /**\n     * Schedules a command to navigate to the given URL.\n     * @param {string} url The fully qualified URL to open.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the document has finished loading.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(url) {\n      return this.navigate().to(url);\n    }\n    /**\n     * Schedules a command to retrieve the URL of the current page.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the current URL.\n     */\n\n  }, {\n    key: \"getCurrentUrl\",\n    value: function getCurrentUrl() {\n      return this.schedule(new command.Command(command.Name.GET_CURRENT_URL), 'WebDriver.getCurrentUrl()');\n    }\n    /**\n     * Schedules a command to retrieve the current page's title.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the current page's title.\n     */\n\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.schedule(new command.Command(command.Name.GET_TITLE), 'WebDriver.getTitle()');\n    }\n    /**\n     * Schedule a command to find an element on the page. If the element cannot be\n     * found, a {@link bot.ErrorCode.NO_SUCH_ELEMENT} result will be returned\n     * by the driver. Unlike other commands, this error cannot be suppressed. In\n     * other words, scheduling a command to find an element doubles as an assert\n     * that the element is present on the page. To test whether an element is\n     * present on the page, use {@link #isElementPresent} instead.\n     *\n     * The search criteria for an element may be defined using one of the\n     * factories in the {@link webdriver.By} namespace, or as a short-hand\n     * {@link webdriver.By.Hash} object. For example, the following two statements\n     * are equivalent:\n     *\n     *     var e1 = driver.findElement(By.id('foo'));\n     *     var e2 = driver.findElement({id:'foo'});\n     *\n     * You may also provide a custom locator function, which takes as input this\n     * instance and returns a {@link WebElement}, or a promise that will resolve\n     * to a WebElement. If the returned promise resolves to an array of\n     * WebElements, WebDriver will use the first element. For example, to find the\n     * first visible link on a page, you could write:\n     *\n     *     var link = driver.findElement(firstVisibleLink);\n     *\n     *     function firstVisibleLink(driver) {\n     *       var links = driver.findElements(By.tagName('a'));\n     *       return promise.filter(links, function(link) {\n     *         return link.isDisplayed();\n     *       });\n     *     }\n     *\n     * @param {!(by.By|Function)} locator The locator to use.\n     * @return {!WebElementPromise} A WebElement that can be used to issue\n     *     commands against the located element. If the element is not found, the\n     *     element will be invalidated and all scheduled commands aborted.\n     */\n\n  }, {\n    key: \"findElement\",\n    value: function findElement(locator) {\n      var id;\n      locator = by.checkedLocator(locator);\n\n      if (typeof locator === 'function') {\n        id = this.findElementInternal_(locator, this);\n      } else {\n        var cmd = new command.Command(command.Name.FIND_ELEMENT).setParameter('using', locator.using).setParameter('value', locator.value);\n        id = this.schedule(cmd, 'WebDriver.findElement(' + locator + ')');\n      }\n\n      return new WebElementPromise(this, id);\n    }\n    /**\n     * @param {!Function} locatorFn The locator function to use.\n     * @param {!(WebDriver|WebElement)} context The search\n     *     context.\n     * @return {!promise.Promise.<!WebElement>} A\n     *     promise that will resolve to a list of WebElements.\n     * @private\n     */\n\n  }, {\n    key: \"findElementInternal_\",\n    value: function findElementInternal_(locatorFn, context) {\n      return this.call(function () {\n        return locatorFn(context);\n      }).then(function (result) {\n        if (Array.isArray(result)) {\n          result = result[0];\n        }\n\n        if (!(result instanceof WebElement)) {\n          throw new TypeError('Custom locator did not return a WebElement');\n        }\n\n        return result;\n      });\n    }\n    /**\n     * Schedules a command to test if an element is present on the page.\n     *\n     * If given a DOM element, this function will check if it belongs to the\n     * document the driver is currently focused on. Otherwise, the function will\n     * test if at least one element can be found with the given search criteria.\n     *\n     * @param {!(by.By|Function)} locator The locator to use.\n     * @return {!promise.Promise<boolean>} A promise that will resolve\n     *     with whether the element is present on the page.\n     * @deprecated This method will be removed in Selenium 3.0 for consistency\n     *     with the other Selenium language bindings. This method is equivalent\n     *     to\n     *\n     *      driver.findElements(locator).then(e => !!e.length);\n     */\n\n  }, {\n    key: \"isElementPresent\",\n    value: function isElementPresent(locator) {\n      return this.findElements.apply(this, arguments).then(function (result) {\n        return !!result.length;\n      });\n    }\n    /**\n     * Schedule a command to search for multiple elements on the page.\n     *\n     * @param {!(by.By|Function)} locator The locator to use.\n     * @return {!promise.Promise.<!Array.<!WebElement>>} A\n     *     promise that will resolve to an array of WebElements.\n     */\n\n  }, {\n    key: \"findElements\",\n    value: function findElements(locator) {\n      locator = by.checkedLocator(locator);\n\n      if (typeof locator === 'function') {\n        return this.findElementsInternal_(locator, this);\n      } else {\n        var cmd = new command.Command(command.Name.FIND_ELEMENTS).setParameter('using', locator.using).setParameter('value', locator.value);\n        var res = this.schedule(cmd, 'WebDriver.findElements(' + locator + ')');\n        return res.catch(function (e) {\n          if (e instanceof error.NoSuchElementError) {\n            return [];\n          }\n\n          throw e;\n        });\n      }\n    }\n    /**\n     * @param {!Function} locatorFn The locator function to use.\n     * @param {!(WebDriver|WebElement)} context The search context.\n     * @return {!promise.Promise<!Array<!WebElement>>} A promise that\n     *     will resolve to an array of WebElements.\n     * @private\n     */\n\n  }, {\n    key: \"findElementsInternal_\",\n    value: function findElementsInternal_(locatorFn, context) {\n      return this.call(function () {\n        return locatorFn(context);\n      }).then(function (result) {\n        if (result instanceof WebElement) {\n          return [result];\n        }\n\n        if (!Array.isArray(result)) {\n          return [];\n        }\n\n        return result.filter(function (item) {\n          return item instanceof WebElement;\n        });\n      });\n    }\n    /**\n     * Schedule a command to take a screenshot. The driver makes a best effort to\n     * return a screenshot of the following, in order of preference:\n     *\n     * 1. Entire page\n     * 2. Current window\n     * 3. Visible portion of the current frame\n     * 4. The entire display containing the browser\n     *\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved to the screenshot as a base-64 encoded PNG.\n     */\n\n  }, {\n    key: \"takeScreenshot\",\n    value: function takeScreenshot() {\n      return this.schedule(new command.Command(command.Name.SCREENSHOT), 'WebDriver.takeScreenshot()');\n    }\n    /**\n     * @return {!Options} The options interface for this instance.\n     */\n\n  }, {\n    key: \"manage\",\n    value: function manage() {\n      return new Options(this);\n    }\n    /**\n     * @return {!Navigation} The navigation interface for this instance.\n     */\n\n  }, {\n    key: \"navigate\",\n    value: function navigate() {\n      return new Navigation(this);\n    }\n    /**\n     * @return {!TargetLocator} The target locator interface for this\n     *     instance.\n     */\n\n  }, {\n    key: \"switchTo\",\n    value: function switchTo() {\n      return new TargetLocator(this);\n    }\n  }], [{\n    key: \"attachToSession\",\n    value: function attachToSession(executor, sessionId, opt_flow) {\n      var flow = opt_flow || promise.controlFlow();\n      var cmd = new command.Command(command.Name.DESCRIBE_SESSION).setParameter('sessionId', sessionId);\n      var session = flow.execute(function () {\n        return executeCommand(executor, cmd);\n      }, 'WebDriver.attachToSession()');\n      session = session.catch(function (err) {\n        // The DESCRIBE_SESSION command is not supported by the W3C spec, so if\n        // we get back an unknown command, just return a session with unknown\n        // capabilities.\n        if (err instanceof error.UnknownCommandError) {\n          return new Session(sessionId, new Capabilities());\n        }\n\n        throw err;\n      });\n      return new WebDriver(session, executor, flow);\n    }\n    /**\n     * Creates a new WebDriver session.\n     * @param {!command.Executor} executor The executor to create the new session\n     *     with.\n     * @param {!./capabilities.Capabilities} desiredCapabilities The desired\n     *     capabilities for the new session.\n     * @param {promise.ControlFlow=} opt_flow The control flow all driver\n     *     commands should execute under, including the initial session creation.\n     *     Defaults to the {@link promise.controlFlow() currently active}\n     *     control flow.\n     * @return {!WebDriver} The driver for the newly created session.\n     */\n\n  }, {\n    key: \"createSession\",\n    value: function createSession(executor, desiredCapabilities, opt_flow) {\n      var flow = opt_flow || promise.controlFlow();\n      var cmd = new command.Command(command.Name.NEW_SESSION).setParameter('desiredCapabilities', desiredCapabilities);\n      var session = flow.execute(function () {\n        return executeCommand(executor, cmd);\n      }, 'WebDriver.createSession()');\n      return new WebDriver(session, executor, flow);\n    }\n  }]);\n\n  return WebDriver;\n}();\n/**\n * Interface for navigating back and forth in the browser history.\n *\n * This class should never be instantiated directly. Insead, obtain an instance\n * with\n *\n *    webdriver.navigate()\n *\n * @see WebDriver#navigate()\n */\n\n\nvar Navigation = /*#__PURE__*/function () {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  function Navigation(driver) {\n    _classCallCheck(this, Navigation);\n\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Schedules a command to navigate to a new URL.\n   * @param {string} url The URL to navigate to.\n   * @return {!promise.Promise<void>} A promise that will be resolved\n   *     when the URL has been loaded.\n   */\n\n\n  _createClass(Navigation, [{\n    key: \"to\",\n    value: function to(url) {\n      return this.driver_.schedule(new command.Command(command.Name.GET).setParameter('url', url), 'WebDriver.navigate().to(' + url + ')');\n    }\n    /**\n     * Schedules a command to move backwards in the browser history.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the navigation event has completed.\n     */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      return this.driver_.schedule(new command.Command(command.Name.GO_BACK), 'WebDriver.navigate().back()');\n    }\n    /**\n     * Schedules a command to move forwards in the browser history.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the navigation event has completed.\n     */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      return this.driver_.schedule(new command.Command(command.Name.GO_FORWARD), 'WebDriver.navigate().forward()');\n    }\n    /**\n     * Schedules a command to refresh the current page.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the navigation event has completed.\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      return this.driver_.schedule(new command.Command(command.Name.REFRESH), 'WebDriver.navigate().refresh()');\n    }\n  }]);\n\n  return Navigation;\n}();\n/**\n * Provides methods for managing browser and driver state.\n *\n * This class should never be instantiated directly. Insead, obtain an instance\n * with\n *\n *    webdriver.manage()\n *\n * @see WebDriver#manage()\n */\n\n\nvar Options = /*#__PURE__*/function () {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  function Options(driver) {\n    _classCallCheck(this, Options);\n\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Schedules a command to add a cookie.\n   * @param {string} name The cookie name.\n   * @param {string} value The cookie value.\n   * @param {string=} opt_path The cookie path.\n   * @param {string=} opt_domain The cookie domain.\n   * @param {boolean=} opt_isSecure Whether the cookie is secure.\n   * @param {(number|!Date)=} opt_expiry When the cookie expires. If specified\n   *     as a number, should be in milliseconds since midnight,\n   *     January 1, 1970 UTC.\n   * @return {!promise.Promise<void>} A promise that will be resolved\n   *     when the cookie has been added to the page.\n   */\n\n\n  _createClass(Options, [{\n    key: \"addCookie\",\n    value: function addCookie(name, value, opt_path, opt_domain, opt_isSecure, opt_expiry) {\n      // We do not allow '=' or ';' in the name.\n      if (/[;=]/.test(name)) {\n        throw new error.InvalidArgumentError('Invalid cookie name \"' + name + '\"');\n      } // We do not allow ';' in value.\n\n\n      if (/;/.test(value)) {\n        throw new error.InvalidArgumentError('Invalid cookie value \"' + value + '\"');\n      }\n\n      var cookieString = name + '=' + value + (opt_domain ? ';domain=' + opt_domain : '') + (opt_path ? ';path=' + opt_path : '') + (opt_isSecure ? ';secure' : '');\n      var expiry;\n\n      if (opt_expiry !== void 0) {\n        var expiryDate;\n\n        if (typeof opt_expiry === 'number') {\n          expiryDate = new Date(opt_expiry);\n        } else {\n          expiryDate =\n          /** @type {!Date} */\n          opt_expiry;\n          opt_expiry = expiryDate.getTime();\n        }\n\n        cookieString += ';expires=' + expiryDate.toUTCString(); // Convert from milliseconds to seconds.\n\n        expiry = Math.floor(\n        /** @type {number} */\n        opt_expiry / 1000);\n      }\n\n      return this.driver_.schedule(new command.Command(command.Name.ADD_COOKIE).setParameter('cookie', {\n        'name': name,\n        'value': value,\n        'path': opt_path,\n        'domain': opt_domain,\n        'secure': !!opt_isSecure,\n        'expiry': expiry\n      }), 'WebDriver.manage().addCookie(' + cookieString + ')');\n    }\n    /**\n     * Schedules a command to delete all cookies visible to the current page.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when all cookies have been deleted.\n     */\n\n  }, {\n    key: \"deleteAllCookies\",\n    value: function deleteAllCookies() {\n      return this.driver_.schedule(new command.Command(command.Name.DELETE_ALL_COOKIES), 'WebDriver.manage().deleteAllCookies()');\n    }\n    /**\n     * Schedules a command to delete the cookie with the given name. This command is\n     * a no-op if there is no cookie with the given name visible to the current\n     * page.\n     * @param {string} name The name of the cookie to delete.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the cookie has been deleted.\n     */\n\n  }, {\n    key: \"deleteCookie\",\n    value: function deleteCookie(name) {\n      return this.driver_.schedule(new command.Command(command.Name.DELETE_COOKIE).setParameter('name', name), 'WebDriver.manage().deleteCookie(' + name + ')');\n    }\n    /**\n     * Schedules a command to retrieve all cookies visible to the current page.\n     * Each cookie will be returned as a JSON object as described by the WebDriver\n     * wire protocol.\n     * @return {!promise.Promise<!Array<WebDriver.Options.Cookie>>} A\n     *     promise that will be resolved with the cookies visible to the current page.\n     */\n\n  }, {\n    key: \"getCookies\",\n    value: function getCookies() {\n      return this.driver_.schedule(new command.Command(command.Name.GET_ALL_COOKIES), 'WebDriver.manage().getCookies()');\n    }\n    /**\n     * Schedules a command to retrieve the cookie with the given name. Returns null\n     * if there is no such cookie. The cookie will be returned as a JSON object as\n     * described by the WebDriver wire protocol.\n     *\n     * @param {string} name The name of the cookie to retrieve.\n     * @return {!promise.Promise<?WebDriver.Options.Cookie>} A promise\n     *     that will be resolved with the named cookie, or `null` if there is no\n     *     such cookie.\n     */\n\n  }, {\n    key: \"getCookie\",\n    value: function getCookie(name) {\n      return this.getCookies().then(function (cookies) {\n        var _iterator = _createForOfIteratorHelper(cookies),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var cookie = _step.value;\n\n            if (cookie && cookie['name'] === name) {\n              return cookie;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return null;\n      });\n    }\n    /**\n     * @return {!Logs} The interface for managing driver\n     *     logs.\n     */\n\n  }, {\n    key: \"logs\",\n    value: function logs() {\n      return new Logs(this.driver_);\n    }\n    /**\n     * @return {!Timeouts} The interface for managing driver timeouts.\n     */\n\n  }, {\n    key: \"timeouts\",\n    value: function timeouts() {\n      return new Timeouts(this.driver_);\n    }\n    /**\n     * @return {!Window} The interface for managing the current window.\n     */\n\n  }, {\n    key: \"window\",\n    value: function window() {\n      return new Window(this.driver_);\n    }\n  }]);\n\n  return Options;\n}();\n/**\n * A JSON description of a browser cookie.\n * @typedef {{\n *     name: string,\n *     value: string,\n *     path: (string|undefined),\n *     domain: (string|undefined),\n *     secure: (boolean|undefined),\n *     expiry: (number|undefined)\n * }}\n */\n\n\nOptions.Cookie;\n/**\n * An interface for managing timeout behavior for WebDriver instances.\n *\n * This class should never be instantiated directly. Insead, obtain an instance\n * with\n *\n *    webdriver.manage().timeouts()\n *\n * @see WebDriver#manage()\n * @see Options#timeouts()\n */\n\nvar Timeouts = /*#__PURE__*/function () {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  function Timeouts(driver) {\n    _classCallCheck(this, Timeouts);\n\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Specifies the amount of time the driver should wait when searching for an\n   * element if it is not immediately present.\n   *\n   * When searching for a single element, the driver should poll the page\n   * until the element has been found, or this timeout expires before failing\n   * with a {@link bot.ErrorCode.NO_SUCH_ELEMENT} error. When searching\n   * for multiple elements, the driver should poll the page until at least one\n   * element has been found or this timeout has expired.\n   *\n   * Setting the wait timeout to 0 (its default value), disables implicit\n   * waiting.\n   *\n   * Increasing the implicit wait timeout should be used judiciously as it\n   * will have an adverse effect on test run time, especially when used with\n   * slower location strategies like XPath.\n   *\n   * @param {number} ms The amount of time to wait, in milliseconds.\n   * @return {!promise.Promise<void>} A promise that will be resolved\n   *     when the implicit wait timeout has been set.\n   */\n\n\n  _createClass(Timeouts, [{\n    key: \"implicitlyWait\",\n    value: function implicitlyWait(ms) {\n      return this.driver_.schedule(new command.Command(command.Name.IMPLICITLY_WAIT).setParameter('ms', ms < 0 ? 0 : ms), 'WebDriver.manage().timeouts().implicitlyWait(' + ms + ')');\n    }\n    /**\n     * Sets the amount of time to wait, in milliseconds, for an asynchronous\n     * script to finish execution before returning an error. If the timeout is\n     * less than or equal to 0, the script will be allowed to run indefinitely.\n     *\n     * @param {number} ms The amount of time to wait, in milliseconds.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the script timeout has been set.\n     */\n\n  }, {\n    key: \"setScriptTimeout\",\n    value: function setScriptTimeout(ms) {\n      return this.driver_.schedule(new command.Command(command.Name.SET_SCRIPT_TIMEOUT).setParameter('ms', ms < 0 ? 0 : ms), 'WebDriver.manage().timeouts().setScriptTimeout(' + ms + ')');\n    }\n    /**\n     * Sets the amount of time to wait for a page load to complete before\n     * returning an error.  If the timeout is negative, page loads may be\n     * indefinite.\n     *\n     * @param {number} ms The amount of time to wait, in milliseconds.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the timeout has been set.\n     */\n\n  }, {\n    key: \"pageLoadTimeout\",\n    value: function pageLoadTimeout(ms) {\n      return this.driver_.schedule(new command.Command(command.Name.SET_TIMEOUT).setParameter('type', 'page load').setParameter('ms', ms), 'WebDriver.manage().timeouts().pageLoadTimeout(' + ms + ')');\n    }\n  }]);\n\n  return Timeouts;\n}();\n/**\n * An interface for managing the current window.\n *\n * This class should never be instantiated directly. Insead, obtain an instance\n * with\n *\n *    webdriver.manage().window()\n *\n * @see WebDriver#manage()\n * @see Options#window()\n */\n\n\nvar Window = /*#__PURE__*/function () {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  function Window(driver) {\n    _classCallCheck(this, Window);\n\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Retrieves the window's current position, relative to the top left corner of\n   * the screen.\n   * @return {!promise.Promise.<{x: number, y: number}>} A promise\n   *     that will be resolved with the window's position in the form of a\n   *     {x:number, y:number} object literal.\n   */\n\n\n  _createClass(Window, [{\n    key: \"getPosition\",\n    value: function getPosition() {\n      return this.driver_.schedule(new command.Command(command.Name.GET_WINDOW_POSITION).setParameter('windowHandle', 'current'), 'WebDriver.manage().window().getPosition()');\n    }\n    /**\n     * Repositions the current window.\n     * @param {number} x The desired horizontal position, relative to the left\n     *     side of the screen.\n     * @param {number} y The desired vertical position, relative to the top of the\n     *     of the screen.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the command has completed.\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(x, y) {\n      return this.driver_.schedule(new command.Command(command.Name.SET_WINDOW_POSITION).setParameter('windowHandle', 'current').setParameter('x', x).setParameter('y', y), 'WebDriver.manage().window().setPosition(' + x + ', ' + y + ')');\n    }\n    /**\n     * Retrieves the window's current size.\n     * @return {!promise.Promise<{width: number, height: number}>} A\n     *     promise that will be resolved with the window's size in the form of a\n     *     {width:number, height:number} object literal.\n     */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return this.driver_.schedule(new command.Command(command.Name.GET_WINDOW_SIZE).setParameter('windowHandle', 'current'), 'WebDriver.manage().window().getSize()');\n    }\n    /**\n     * Resizes the current window.\n     * @param {number} width The desired window width.\n     * @param {number} height The desired window height.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the command has completed.\n     */\n\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      return this.driver_.schedule(new command.Command(command.Name.SET_WINDOW_SIZE).setParameter('windowHandle', 'current').setParameter('width', width).setParameter('height', height), 'WebDriver.manage().window().setSize(' + width + ', ' + height + ')');\n    }\n    /**\n     * Maximizes the current window.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the command has completed.\n     */\n\n  }, {\n    key: \"maximize\",\n    value: function maximize() {\n      return this.driver_.schedule(new command.Command(command.Name.MAXIMIZE_WINDOW).setParameter('windowHandle', 'current'), 'WebDriver.manage().window().maximize()');\n    }\n  }]);\n\n  return Window;\n}();\n/**\n * Interface for managing WebDriver log records.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.manage().logs()\n *\n * @see WebDriver#manage()\n * @see Options#logs()\n */\n\n\nvar Logs = /*#__PURE__*/function () {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  function Logs(driver) {\n    _classCallCheck(this, Logs);\n\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Fetches available log entries for the given type.\n   *\n   * Note that log buffers are reset after each call, meaning that available\n   * log entries correspond to those entries not yet returned for a given log\n   * type. In practice, this means that this call will return the available log\n   * entries since the last call, or from the start of the session.\n   *\n   * @param {!logging.Type} type The desired log type.\n   * @return {!promise.Promise.<!Array.<!logging.Entry>>} A\n   *   promise that will resolve to a list of log entries for the specified\n   *   type.\n   */\n\n\n  _createClass(Logs, [{\n    key: \"get\",\n    value: function get(type) {\n      var cmd = new command.Command(command.Name.GET_LOG).setParameter('type', type);\n      return this.driver_.schedule(cmd, 'WebDriver.manage().logs().get(' + type + ')').then(function (entries) {\n        return entries.map(function (entry) {\n          if (!(entry instanceof logging.Entry)) {\n            return new logging.Entry(entry['level'], entry['message'], entry['timestamp'], entry['type']);\n          }\n\n          return entry;\n        });\n      });\n    }\n    /**\n     * Retrieves the log types available to this driver.\n     * @return {!promise.Promise<!Array<!logging.Type>>} A\n     *     promise that will resolve to a list of available log types.\n     */\n\n  }, {\n    key: \"getAvailableLogTypes\",\n    value: function getAvailableLogTypes() {\n      return this.driver_.schedule(new command.Command(command.Name.GET_AVAILABLE_LOG_TYPES), 'WebDriver.manage().logs().getAvailableLogTypes()');\n    }\n  }]);\n\n  return Logs;\n}();\n/**\n * An interface for changing the focus of the driver to another frame or window.\n *\n * This class should never be instantiated directly. Instead, obtain an\n * instance with\n *\n *     webdriver.switchTo()\n *\n * @see WebDriver#switchTo()\n */\n\n\nvar TargetLocator = /*#__PURE__*/function () {\n  /**\n   * @param {!WebDriver} driver The parent driver.\n   * @private\n   */\n  function TargetLocator(driver) {\n    _classCallCheck(this, TargetLocator);\n\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n  }\n  /**\n   * Schedules a command retrieve the {@code document.activeElement} element on\n   * the current document, or {@code document.body} if activeElement is not\n   * available.\n   * @return {!WebElementPromise} The active element.\n   */\n\n\n  _createClass(TargetLocator, [{\n    key: \"activeElement\",\n    value: function activeElement() {\n      var id = this.driver_.schedule(new command.Command(command.Name.GET_ACTIVE_ELEMENT), 'WebDriver.switchTo().activeElement()');\n      return new WebElementPromise(this.driver_, id);\n    }\n    /**\n     * Schedules a command to switch focus of all future commands to the topmost\n     * frame on the page.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the driver has changed focus to the default content.\n     */\n\n  }, {\n    key: \"defaultContent\",\n    value: function defaultContent() {\n      return this.driver_.schedule(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', null), 'WebDriver.switchTo().defaultContent()');\n    }\n    /**\n     * Schedules a command to switch the focus of all future commands to another\n     * frame on the page. The target frame may be specified as one of the\n     * following:\n     *\n     * - A number that specifies a (zero-based) index into [window.frames](\n     *   https://developer.mozilla.org/en-US/docs/Web/API/Window.frames).\n     * - A {@link WebElement} reference, which correspond to a `frame` or `iframe`\n     *   DOM element.\n     * - The `null` value, to select the topmost frame on the page. Passing `null`\n     *   is the same as calling {@link #defaultContent defaultContent()}.\n     *\n     * If the specified frame can not be found, the returned promise will be\n     * rejected with a {@linkplain error.NoSuchFrameError}.\n     *\n     * @param {(number|WebElement|null)} id The frame locator.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the driver has changed focus to the specified frame.\n     */\n\n  }, {\n    key: \"frame\",\n    value: function frame(id) {\n      return this.driver_.schedule(new command.Command(command.Name.SWITCH_TO_FRAME).setParameter('id', id), 'WebDriver.switchTo().frame(' + id + ')');\n    }\n    /**\n     * Schedules a command to switch the focus of all future commands to another\n     * window. Windows may be specified by their {@code window.name} attribute or\n     * by its handle (as returned by {@link WebDriver#getWindowHandles}).\n     *\n     * If the specified window cannot be found, the returned promise will be\n     * rejected with a {@linkplain error.NoSuchWindowError}.\n     *\n     * @param {string} nameOrHandle The name or window handle of the window to\n     *     switch focus to.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the driver has changed focus to the specified window.\n     */\n\n  }, {\n    key: \"window\",\n    value: function window(nameOrHandle) {\n      return this.driver_.schedule(new command.Command(command.Name.SWITCH_TO_WINDOW).setParameter('name', nameOrHandle), 'WebDriver.switchTo().window(' + nameOrHandle + ')');\n    }\n    /**\n     * Schedules a command to change focus to the active modal dialog, such as\n     * those opened by `window.alert()`, `window.confirm()`, and\n     * `window.prompt()`. The returned promise will be rejected with a\n     * {@linkplain error.NoSuchAlertError} if there are no open alerts.\n     *\n     * @return {!AlertPromise} The open alert.\n     */\n\n  }, {\n    key: \"alert\",\n    value: function alert() {\n      var text = this.driver_.schedule(new command.Command(command.Name.GET_ALERT_TEXT), 'WebDriver.switchTo().alert()');\n      var driver = this.driver_;\n      return new AlertPromise(driver, text.then(function (text) {\n        return new Alert(driver, text);\n      }));\n    }\n  }]);\n\n  return TargetLocator;\n}(); //////////////////////////////////////////////////////////////////////////////\n//\n//  WebElement\n//\n//////////////////////////////////////////////////////////////////////////////\n\n\nvar LEGACY_ELEMENT_ID_KEY = 'ELEMENT';\nvar ELEMENT_ID_KEY = 'element-6066-11e4-a52e-4f735466cecf';\n/**\n * Represents a DOM element. WebElements can be found by searching from the\n * document root using a {@link WebDriver} instance, or by searching\n * under another WebElement:\n *\n *     driver.get('http://www.google.com');\n *     var searchForm = driver.findElement(By.tagName('form'));\n *     var searchBox = searchForm.findElement(By.name('q'));\n *     searchBox.sendKeys('webdriver');\n */\n\nvar WebElement = /*#__PURE__*/function (_Symbols$serialize) {\n  /**\n   * @param {!WebDriver} driver the parent WebDriver instance for this element.\n   * @param {(!IThenable<string>|string)} id The server-assigned opaque ID for\n   *     the underlying DOM element.\n   */\n  function WebElement(driver, id) {\n    _classCallCheck(this, WebElement);\n\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n    /** @private {!promise.Promise<string>} */\n\n    this.id_ = promise.fulfilled(id);\n  }\n  /**\n   * @param {string} id The raw ID.\n   * @param {boolean=} opt_noLegacy Whether to exclude the legacy element key.\n   * @return {!Object} The element ID for use with WebDriver's wire protocol.\n   */\n\n\n  _createClass(WebElement, [{\n    key: \"getDriver\",\n    value:\n    /** @return {!WebDriver} The parent driver for this instance. */\n    function getDriver() {\n      return this.driver_;\n    }\n    /**\n     * @return {!promise.Promise<string>} A promise that resolves to\n     *     the server-assigned opaque ID assigned to this element.\n     */\n\n  }, {\n    key: \"getId\",\n    value: function getId() {\n      return this.id_;\n    }\n    /**\n     * @deprecated Use {@link #getId()} instead.\n     */\n\n  }, {\n    key: \"getRawId\",\n    value: function getRawId() {\n      return this.getId();\n    }\n    /**\n     * @return {!Object} Returns the serialized representation of this WebElement.\n     */\n\n  }, {\n    key: _Symbols$serialize,\n    value: function value() {\n      return this.getId().then(WebElement.buildId);\n    }\n    /**\n     * Schedules a command that targets this element with the parent WebDriver\n     * instance. Will ensure this element's ID is included in the command\n     * parameters under the \"id\" key.\n     *\n     * @param {!command.Command} command The command to schedule.\n     * @param {string} description A description of the command for debugging.\n     * @return {!promise.Promise<T>} A promise that will be resolved\n     *     with the command result.\n     * @template T\n     * @see WebDriver#schedule\n     * @private\n     */\n\n  }, {\n    key: \"schedule_\",\n    value: function schedule_(command, description) {\n      command.setParameter('id', this.getId());\n      return this.driver_.schedule(command, description);\n    }\n    /**\n     * Schedule a command to find a descendant of this element. If the element\n     * cannot be found, the returned promise will be rejected with a\n     * {@linkplain error.NoSuchElementError NoSuchElementError}.\n     *\n     * The search criteria for an element may be defined using one of the static\n     * factories on the {@link by.By} class, or as a short-hand\n     * {@link ./by.ByHash} object. For example, the following two statements\n     * are equivalent:\n     *\n     *     var e1 = element.findElement(By.id('foo'));\n     *     var e2 = element.findElement({id:'foo'});\n     *\n     * You may also provide a custom locator function, which takes as input this\n     * instance and returns a {@link WebElement}, or a promise that will resolve\n     * to a WebElement. If the returned promise resolves to an array of\n     * WebElements, WebDriver will use the first element. For example, to find the\n     * first visible link on a page, you could write:\n     *\n     *     var link = element.findElement(firstVisibleLink);\n     *\n     *     function firstVisibleLink(element) {\n     *       var links = element.findElements(By.tagName('a'));\n     *       return promise.filter(links, function(link) {\n     *         return link.isDisplayed();\n     *       });\n     *     }\n     *\n     * @param {!(by.By|Function)} locator The locator strategy to use when\n     *     searching for the element.\n     * @return {!WebElementPromise} A WebElement that can be used to issue\n     *     commands against the located element. If the element is not found, the\n     *     element will be invalidated and all scheduled commands aborted.\n     */\n\n  }, {\n    key: \"findElement\",\n    value: function findElement(locator) {\n      locator = by.checkedLocator(locator);\n      var id;\n\n      if (typeof locator === 'function') {\n        id = this.driver_.findElementInternal_(locator, this);\n      } else {\n        var cmd = new command.Command(command.Name.FIND_CHILD_ELEMENT).setParameter('using', locator.using).setParameter('value', locator.value);\n        id = this.schedule_(cmd, 'WebElement.findElement(' + locator + ')');\n      }\n\n      return new WebElementPromise(this.driver_, id);\n    }\n    /**\n     * Schedules a command to test if there is at least one descendant of this\n     * element that matches the given search criteria.\n     *\n     * @param {!(by.By|Function)} locator The locator strategy to use when\n     *     searching for the element.\n     * @return {!promise.Promise<boolean>} A promise that will be\n     *     resolved with whether an element could be located on the page.\n     * @deprecated This method will be removed in Selenium 3.0 for consistency\n     *     with the other Selenium language bindings. This method is equivalent\n     *     to\n     *\n     *      element.findElements(locator).then(e => !!e.length);\n     */\n\n  }, {\n    key: \"isElementPresent\",\n    value: function isElementPresent(locator) {\n      return this.findElements(locator).then(function (result) {\n        return !!result.length;\n      });\n    }\n    /**\n     * Schedules a command to find all of the descendants of this element that\n     * match the given search criteria.\n     *\n     * @param {!(by.By|Function)} locator The locator strategy to use when\n     *     searching for the element.\n     * @return {!promise.Promise<!Array<!WebElement>>} A\n     *     promise that will resolve to an array of WebElements.\n     */\n\n  }, {\n    key: \"findElements\",\n    value: function findElements(locator) {\n      locator = by.checkedLocator(locator);\n      var id;\n\n      if (typeof locator === 'function') {\n        return this.driver_.findElementsInternal_(locator, this);\n      } else {\n        var cmd = new command.Command(command.Name.FIND_CHILD_ELEMENTS).setParameter('using', locator.using).setParameter('value', locator.value);\n        return this.schedule_(cmd, 'WebElement.findElements(' + locator + ')');\n      }\n    }\n    /**\n     * Schedules a command to click on this element.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the click command has completed.\n     */\n\n  }, {\n    key: \"click\",\n    value: function click() {\n      return this.schedule_(new command.Command(command.Name.CLICK_ELEMENT), 'WebElement.click()');\n    }\n    /**\n     * Schedules a command to type a sequence on the DOM element represented by\n     * this instance.\n     *\n     * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n     * processed in the keysequence, that key state is toggled until one of the\n     * following occurs:\n     *\n     * - The modifier key is encountered again in the sequence. At this point the\n     *   state of the key is toggled (along with the appropriate keyup/down\n     *   events).\n     * - The {@link input.Key.NULL} key is encountered in the sequence. When\n     *   this key is encountered, all modifier keys current in the down state are\n     *   released (with accompanying keyup events). The NULL key can be used to\n     *   simulate common keyboard shortcuts:\n     *\n     *         element.sendKeys(\"text was\",\n     *                          Key.CONTROL, \"a\", Key.NULL,\n     *                          \"now text is\");\n     *         // Alternatively:\n     *         element.sendKeys(\"text was\",\n     *                          Key.chord(Key.CONTROL, \"a\"),\n     *                          \"now text is\");\n     *\n     * - The end of the keysequence is encountered. When there are no more keys\n     *   to type, all depressed modifier keys are released (with accompanying\n     *   keyup events).\n     *\n     * If this element is a file input ({@code <input type=\"file\">}), the\n     * specified key sequence should specify the path to the file to attach to\n     * the element. This is analgous to the user clicking \"Browse...\" and entering\n     * the path into the file select dialog.\n     *\n     *     var form = driver.findElement(By.css('form'));\n     *     var element = form.findElement(By.css('input[type=file]'));\n     *     element.sendKeys('/path/to/file.txt');\n     *     form.submit();\n     *\n     * For uploads to function correctly, the entered path must reference a file\n     * on the _browser's_ machine, not the local machine running this script. When\n     * running against a remote Selenium server, a {@link input.FileDetector}\n     * may be used to transparently copy files to the remote machine before\n     * attempting to upload them in the browser.\n     *\n     * __Note:__ On browsers where native keyboard events are not supported\n     * (e.g. Firefox on OS X), key events will be synthesized. Special\n     * punctionation keys will be synthesized according to a standard QWERTY en-us\n     * keyboard layout.\n     *\n     * @param {...(string|!promise.Promise<string>)} var_args The\n     *     sequence of keys to type. All arguments will be joined into a single\n     *     sequence.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when all keys have been typed.\n     */\n\n  }, {\n    key: \"sendKeys\",\n    value: function sendKeys(var_args) {\n      // Coerce every argument to a string. This protects us from users that\n      // ignore the jsdoc and give us a number (which ends up causing problems on\n      // the server, which requires strings).\n      var keys = promise.all(Array.prototype.slice.call(arguments, 0)).then(function (keys) {\n        var ret = [];\n        keys.forEach(function (key) {\n          if (typeof key !== 'string') {\n            key = String(key);\n          } // The W3C protocol requires keys to be specified as an array where\n          // each element is a single key.\n\n\n          ret.push.apply(ret, key.split(''));\n        });\n        return ret;\n      });\n\n      if (!this.driver_.fileDetector_) {\n        return this.schedule_(new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).setParameter('value', keys), 'WebElement.sendKeys()');\n      } // Suppress unhandled rejection errors until the flow executes the command.\n\n\n      keys.catch(function () {});\n      var element = this;\n      return this.driver_.flow_.execute(function () {\n        return keys.then(function (keys) {\n          return element.driver_.fileDetector_.handleFile(element.driver_, keys.join(''));\n        }).then(function (keys) {\n          return element.schedule_(new command.Command(command.Name.SEND_KEYS_TO_ELEMENT).setParameter('value', [keys]), 'WebElement.sendKeys()');\n        });\n      }, 'WebElement.sendKeys()');\n    }\n    /**\n     * Schedules a command to query for the tag/node name of this element.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the element's tag name.\n     */\n\n  }, {\n    key: \"getTagName\",\n    value: function getTagName() {\n      return this.schedule_(new command.Command(command.Name.GET_ELEMENT_TAG_NAME), 'WebElement.getTagName()');\n    }\n    /**\n     * Schedules a command to query for the computed style of the element\n     * represented by this instance. If the element inherits the named style from\n     * its parent, the parent will be queried for its value.  Where possible, color\n     * values will be converted to their hex representation (e.g. #00ff00 instead\n     * of rgb(0, 255, 0)).\n     *\n     * _Warning:_ the value returned will be as the browser interprets it, so\n     * it may be tricky to form a proper assertion.\n     *\n     * @param {string} cssStyleProperty The name of the CSS style property to look\n     *     up.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the requested CSS value.\n     */\n\n  }, {\n    key: \"getCssValue\",\n    value: function getCssValue(cssStyleProperty) {\n      var name = command.Name.GET_ELEMENT_VALUE_OF_CSS_PROPERTY;\n      return this.schedule_(new command.Command(name).setParameter('propertyName', cssStyleProperty), 'WebElement.getCssValue(' + cssStyleProperty + ')');\n    }\n    /**\n     * Schedules a command to query for the value of the given attribute of the\n     * element. Will return the current value, even if it has been modified after\n     * the page has been loaded. More exactly, this method will return the value\n     * of the given attribute, unless that attribute is not present, in which case\n     * the value of the property with the same name is returned. If neither value\n     * is set, null is returned (for example, the \"value\" property of a textarea\n     * element). The \"style\" attribute is converted as best can be to a\n     * text representation with a trailing semi-colon. The following are deemed to\n     * be \"boolean\" attributes and will return either \"true\" or null:\n     *\n     * async, autofocus, autoplay, checked, compact, complete, controls, declare,\n     * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n     * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n     * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n     * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n     * selected, spellcheck, truespeed, willvalidate\n     *\n     * Finally, the following commonly mis-capitalized attribute/property names\n     * are evaluated as expected:\n     *\n     * - \"class\"\n     * - \"readonly\"\n     *\n     * @param {string} attributeName The name of the attribute to query.\n     * @return {!promise.Promise<?string>} A promise that will be\n     *     resolved with the attribute's value. The returned value will always be\n     *     either a string or null.\n     */\n\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(attributeName) {\n      return this.schedule_(new command.Command(command.Name.GET_ELEMENT_ATTRIBUTE).setParameter('name', attributeName), 'WebElement.getAttribute(' + attributeName + ')');\n    }\n    /**\n     * Get the visible (i.e. not hidden by CSS) innerText of this element,\n     * including sub-elements, without any leading or trailing whitespace.\n     *\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the element's visible text.\n     */\n\n  }, {\n    key: \"getText\",\n    value: function getText() {\n      return this.schedule_(new command.Command(command.Name.GET_ELEMENT_TEXT), 'WebElement.getText()');\n    }\n    /**\n     * Schedules a command to compute the size of this element's bounding box, in\n     * pixels.\n     * @return {!promise.Promise.<{width: number, height: number}>} A\n     *     promise that will be resolved with the element's size as a\n     *     {@code {width:number, height:number}} object.\n     */\n\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      return this.schedule_(new command.Command(command.Name.GET_ELEMENT_SIZE), 'WebElement.getSize()');\n    }\n    /**\n     * Schedules a command to compute the location of this element in page space.\n     * @return {!promise.Promise.<{x: number, y: number}>} A promise that\n     *     will be resolved to the element's location as a\n     *     {@code {x:number, y:number}} object.\n     */\n\n  }, {\n    key: \"getLocation\",\n    value: function getLocation() {\n      return this.schedule_(new command.Command(command.Name.GET_ELEMENT_LOCATION), 'WebElement.getLocation()');\n    }\n    /**\n     * Schedules a command to query whether the DOM element represented by this\n     * instance is enabled, as dicted by the {@code disabled} attribute.\n     * @return {!promise.Promise<boolean>} A promise that will be\n     *     resolved with whether this element is currently enabled.\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return this.schedule_(new command.Command(command.Name.IS_ELEMENT_ENABLED), 'WebElement.isEnabled()');\n    }\n    /**\n     * Schedules a command to query whether this element is selected.\n     * @return {!promise.Promise<boolean>} A promise that will be\n     *     resolved with whether this element is currently selected.\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.schedule_(new command.Command(command.Name.IS_ELEMENT_SELECTED), 'WebElement.isSelected()');\n    }\n    /**\n     * Schedules a command to submit the form containing this element (or this\n     * element if it is a FORM element). This command is a no-op if the element is\n     * not contained in a form.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the form has been submitted.\n     */\n\n  }, {\n    key: \"submit\",\n    value: function submit() {\n      return this.schedule_(new command.Command(command.Name.SUBMIT_ELEMENT), 'WebElement.submit()');\n    }\n    /**\n     * Schedules a command to clear the `value` of this element. This command has\n     * no effect if the underlying DOM element is neither a text INPUT element\n     * nor a TEXTAREA element.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when the element has been cleared.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      return this.schedule_(new command.Command(command.Name.CLEAR_ELEMENT), 'WebElement.clear()');\n    }\n    /**\n     * Schedules a command to test whether this element is currently displayed.\n     * @return {!promise.Promise<boolean>} A promise that will be\n     *     resolved with whether this element is currently visible on the page.\n     */\n\n  }, {\n    key: \"isDisplayed\",\n    value: function isDisplayed() {\n      return this.schedule_(new command.Command(command.Name.IS_ELEMENT_DISPLAYED), 'WebElement.isDisplayed()');\n    }\n    /**\n     * Take a screenshot of the visible region encompassed by this element's\n     * bounding rectangle.\n     *\n     * @param {boolean=} opt_scroll Optional argument that indicates whether the\n     *     element should be scrolled into view before taking a screenshot.\n     *     Defaults to false.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved to the screenshot as a base-64 encoded PNG.\n     */\n\n  }, {\n    key: \"takeScreenshot\",\n    value: function takeScreenshot(opt_scroll) {\n      var scroll = !!opt_scroll;\n      return this.schedule_(new command.Command(command.Name.TAKE_ELEMENT_SCREENSHOT).setParameter('scroll', scroll), 'WebElement.takeScreenshot(' + scroll + ')');\n    }\n    /**\n     * Schedules a command to retrieve the outer HTML of this element.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the element's outer HTML.\n     * @deprecated Use {@link WebDriver#executeScript()}\n     */\n\n  }, {\n    key: \"getOuterHtml\",\n    value: function getOuterHtml() {\n      return this.driver_.executeScript(function () {\n        var element =\n        /** @type {!Element} */\n        arguments[0];\n\n        if ('outerHTML' in element) {\n          return element.outerHTML;\n        } else {\n          var div = element.ownerDocument.createElement('div');\n          div.appendChild(element.cloneNode(true));\n          return div.innerHTML;\n        }\n      }, this);\n    }\n    /**\n     * Schedules a command to retrieve the inner HTML of this element.\n     * @return {!promise.Promise<string>} A promise that will be\n     *     resolved with the element's inner HTML.\n     * @deprecated Use {@link WebDriver#executeScript()}\n     */\n\n  }, {\n    key: \"getInnerHtml\",\n    value: function getInnerHtml() {\n      return this.driver_.executeScript('return arguments[0].innerHTML', this);\n    }\n  }], [{\n    key: \"buildId\",\n    value: function buildId(id, opt_noLegacy) {\n      var _ref2;\n\n      return opt_noLegacy ? _defineProperty({}, ELEMENT_ID_KEY, id) : (_ref2 = {}, _defineProperty(_ref2, ELEMENT_ID_KEY, id), _defineProperty(_ref2, LEGACY_ELEMENT_ID_KEY, id), _ref2);\n    }\n    /**\n     * Extracts the encoded WebElement ID from the object.\n     *\n     * @param {?} obj The object to extract the ID from.\n     * @return {string} the extracted ID.\n     * @throws {TypeError} if the object is not a valid encoded ID.\n     */\n\n  }, {\n    key: \"extractId\",\n    value: function extractId(obj) {\n      if (obj && typeof obj === 'object') {\n        if (typeof obj[ELEMENT_ID_KEY] === 'string') {\n          return obj[ELEMENT_ID_KEY];\n        } else if (typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string') {\n          return obj[LEGACY_ELEMENT_ID_KEY];\n        }\n      }\n\n      throw new TypeError('object is not a WebElement ID');\n    }\n    /**\n     * @param {?} obj the object to test.\n     * @return {boolean} whether the object is a valid encoded WebElement ID.\n     */\n\n  }, {\n    key: \"isId\",\n    value: function isId(obj) {\n      return obj && typeof obj === 'object' && (typeof obj[ELEMENT_ID_KEY] === 'string' || typeof obj[LEGACY_ELEMENT_ID_KEY] === 'string');\n    }\n    /**\n     * Compares two WebElements for equality.\n     *\n     * @param {!WebElement} a A WebElement.\n     * @param {!WebElement} b A WebElement.\n     * @return {!promise.Promise<boolean>} A promise that will be\n     *     resolved to whether the two WebElements are equal.\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(a, b) {\n      if (a === b) {\n        return promise.fulfilled(true);\n      }\n\n      var ids = [a.getId(), b.getId()];\n      return promise.all(ids).then(function (ids) {\n        // If the two element's have the same ID, they should be considered\n        // equal. Otherwise, they may still be equivalent, but we'll need to\n        // ask the server to check for us.\n        if (ids[0] === ids[1]) {\n          return true;\n        }\n\n        var cmd = new command.Command(command.Name.ELEMENT_EQUALS);\n        cmd.setParameter('id', ids[0]);\n        cmd.setParameter('other', ids[1]);\n        return a.driver_.schedule(cmd, 'WebElement.equals()');\n      });\n    }\n  }]);\n\n  return WebElement;\n}(Symbols.serialize);\n/**\n * WebElementPromise is a promise that will be fulfilled with a WebElement.\n * This serves as a forward proxy on WebElement, allowing calls to be\n * scheduled without directly on this instance before the underlying\n * WebElement has been fulfilled. In other words, the following two statements\n * are equivalent:\n *\n *     driver.findElement({id: 'my-button'}).click();\n *     driver.findElement({id: 'my-button'}).then(function(el) {\n *       return el.click();\n *     });\n *\n * @implements {promise.Thenable<!WebElement>}\n * @final\n */\n\n\nvar WebElementPromise = /*#__PURE__*/function (_WebElement) {\n  _inherits(WebElementPromise, _WebElement);\n\n  var _super2 = _createSuper(WebElementPromise);\n\n  /**\n   * @param {!WebDriver} driver The parent WebDriver instance for this\n   *     element.\n   * @param {!promise.Promise<!WebElement>} el A promise\n   *     that will resolve to the promised element.\n   */\n  function WebElementPromise(driver, el) {\n    var _this2;\n\n    _classCallCheck(this, WebElementPromise);\n\n    _this2 = _super2.call(this, driver, 'unused');\n    /** @override */\n\n    _this2.cancel = el.cancel.bind(el);\n    /** @override */\n\n    _this2.isPending = el.isPending.bind(el);\n    /** @override */\n\n    _this2.then = el.then.bind(el);\n    /** @override */\n\n    _this2.catch = el.catch.bind(el);\n    /** @override */\n\n    _this2.thenCatch = el.catch.bind(el);\n    /** @override */\n\n    _this2.finally = el.finally.bind(el);\n    /** @override */\n\n    _this2.thenFinally = el.finally.bind(el);\n    /**\n     * Defers returning the element ID until the wrapped WebElement has been\n     * resolved.\n     * @override\n     */\n\n    _this2.getId = function () {\n      return el.then(function (el) {\n        return el.getId();\n      });\n    };\n\n    return _this2;\n  }\n\n  return WebElementPromise;\n}(WebElement);\n\npromise.Thenable.addImplementation(WebElementPromise); //////////////////////////////////////////////////////////////////////////////\n//\n//  Alert\n//\n//////////////////////////////////////////////////////////////////////////////\n\n/**\n * Represents a modal dialog such as {@code alert}, {@code confirm}, or\n * {@code prompt}. Provides functions to retrieve the message displayed with\n * the alert, accept or dismiss the alert, and set the response text (in the\n * case of {@code prompt}).\n */\n\nvar Alert = /*#__PURE__*/function () {\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this alert\n   *     is attached to.\n   * @param {string} text The message text displayed with this alert.\n   */\n  function Alert(driver, text) {\n    _classCallCheck(this, Alert);\n\n    /** @private {!WebDriver} */\n    this.driver_ = driver;\n    /** @private {!promise.Promise<string>} */\n\n    this.text_ = promise.fulfilled(text);\n  }\n  /**\n   * Retrieves the message text displayed with this alert. For instance, if the\n   * alert were opened with alert(\"hello\"), then this would return \"hello\".\n   *\n   * @return {!promise.Promise<string>} A promise that will be\n   *     resolved to the text displayed with this alert.\n   */\n\n\n  _createClass(Alert, [{\n    key: \"getText\",\n    value: function getText() {\n      return this.text_;\n    }\n    /**\n     * Sets the username and password in an alert prompting for credentials (such\n     * as a Basic HTTP Auth prompt). This method will implicitly\n     * {@linkplain #accept() submit} the dialog.\n     *\n     * @param {string} username The username to send.\n     * @param {string} password The password to send.\n     * @return {!promise.Promise<void>} A promise that will be resolved when this\n     *     command has completed.\n     */\n\n  }, {\n    key: \"authenticateAs\",\n    value: function authenticateAs(username, password) {\n      return this.driver_.schedule(new command.Command(command.Name.SET_ALERT_CREDENTIALS), 'WebDriver.switchTo().alert()' + \".authenticateAs(\\\"\".concat(username, \"\\\", \\\"\").concat(password, \"\\\")\"));\n    }\n    /**\n     * Accepts this alert.\n     *\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when this command has completed.\n     */\n\n  }, {\n    key: \"accept\",\n    value: function accept() {\n      return this.driver_.schedule(new command.Command(command.Name.ACCEPT_ALERT), 'WebDriver.switchTo().alert().accept()');\n    }\n    /**\n     * Dismisses this alert.\n     *\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when this command has completed.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function dismiss() {\n      return this.driver_.schedule(new command.Command(command.Name.DISMISS_ALERT), 'WebDriver.switchTo().alert().dismiss()');\n    }\n    /**\n     * Sets the response text on this alert. This command will return an error if\n     * the underlying alert does not support response text (e.g. window.alert and\n     * window.confirm).\n     *\n     * @param {string} text The text to set.\n     * @return {!promise.Promise<void>} A promise that will be resolved\n     *     when this command has completed.\n     */\n\n  }, {\n    key: \"sendKeys\",\n    value: function sendKeys(text) {\n      return this.driver_.schedule(new command.Command(command.Name.SET_ALERT_TEXT).setParameter('text', text), 'WebDriver.switchTo().alert().sendKeys(' + text + ')');\n    }\n  }]);\n\n  return Alert;\n}();\n/**\n * AlertPromise is a promise that will be fulfilled with an Alert. This promise\n * serves as a forward proxy on an Alert, allowing calls to be scheduled\n * directly on this instance before the underlying Alert has been fulfilled. In\n * other words, the following two statements are equivalent:\n *\n *     driver.switchTo().alert().dismiss();\n *     driver.switchTo().alert().then(function(alert) {\n *       return alert.dismiss();\n *     });\n *\n * @implements {promise.Thenable.<!webdriver.Alert>}\n * @final\n */\n\n\nvar AlertPromise = /*#__PURE__*/function (_Alert) {\n  _inherits(AlertPromise, _Alert);\n\n  var _super3 = _createSuper(AlertPromise);\n\n  /**\n   * @param {!WebDriver} driver The driver controlling the browser this\n   *     alert is attached to.\n   * @param {!promise.Thenable<!Alert>} alert A thenable\n   *     that will be fulfilled with the promised alert.\n   */\n  function AlertPromise(driver, alert) {\n    var _this3;\n\n    _classCallCheck(this, AlertPromise);\n\n    _this3 = _super3.call(this, driver, 'unused');\n    /** @override */\n\n    _this3.cancel = alert.cancel.bind(alert);\n    /** @override */\n\n    _this3.isPending = alert.isPending.bind(alert);\n    /** @override */\n\n    _this3.then = alert.then.bind(alert);\n    /** @override */\n\n    _this3.catch = alert.catch.bind(alert);\n    /** @override */\n\n    _this3.thenCatch = alert.catch.bind(alert);\n    /** @override */\n\n    _this3.finally = alert.finally.bind(alert);\n    /** @override */\n\n    _this3.thenFinally = alert.finally.bind(alert);\n    /**\n     * Defer returning text until the promised alert has been resolved.\n     * @override\n     */\n\n    _this3.getText = function () {\n      return alert.then(function (alert) {\n        return alert.getText();\n      });\n    };\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n\n\n    _this3.authenticateAs = function (username, password) {\n      return alert.then(function (alert) {\n        return alert.authenticateAs(username, password);\n      });\n    };\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n\n\n    _this3.accept = function () {\n      return alert.then(function (alert) {\n        return alert.accept();\n      });\n    };\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n\n\n    _this3.dismiss = function () {\n      return alert.then(function (alert) {\n        return alert.dismiss();\n      });\n    };\n    /**\n     * Defers action until the alert has been located.\n     * @override\n     */\n\n\n    _this3.sendKeys = function (text) {\n      return alert.then(function (alert) {\n        return alert.sendKeys(text);\n      });\n    };\n\n    return _this3;\n  }\n\n  return AlertPromise;\n}(Alert);\n\npromise.Thenable.addImplementation(AlertPromise); // PUBLIC API\n\nmodule.exports = {\n  Alert: Alert,\n  AlertPromise: AlertPromise,\n  Condition: Condition,\n  Logs: Logs,\n  Navigation: Navigation,\n  Options: Options,\n  TargetLocator: TargetLocator,\n  Timeouts: Timeouts,\n\n  /** @deprecated Use {@link error.UnexpectedAlertOpenError} instead. */\n  UnhandledAlertError: error.UnexpectedAlertOpenError,\n  WebDriver: WebDriver,\n  WebElement: WebElement,\n  WebElementCondition: WebElementCondition,\n  WebElementPromise: WebElementPromise,\n  Window: Window\n};","map":null,"metadata":{},"sourceType":"script"}