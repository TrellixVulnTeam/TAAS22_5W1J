{"ast":null,"code":"var fs = require(\"fs\"),\n    pth = require('path');\n\nfs.existsSync = fs.existsSync || pth.existsSync;\n\nmodule.exports = function () {\n  var crcTable = [],\n      Constants = require('./constants'),\n      Errors = require('./errors'),\n      PATH_SEPARATOR = pth.normalize(\"/\");\n\n  function mkdirSync(\n  /*String*/\n  path) {\n    var resolvedPath = path.split(PATH_SEPARATOR)[0];\n    path.split(PATH_SEPARATOR).forEach(function (name) {\n      if (!name || name.substr(-1, 1) == \":\") return;\n      resolvedPath += PATH_SEPARATOR + name;\n      var stat;\n\n      try {\n        stat = fs.statSync(resolvedPath);\n      } catch (e) {\n        fs.mkdirSync(resolvedPath);\n      }\n\n      if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY.replace(\"%s\", resolvedPath);\n    });\n  }\n\n  function findSync(\n  /*String*/\n  root,\n  /*RegExp*/\n  pattern,\n  /*Boolean*/\n  recoursive) {\n    if (typeof pattern === 'boolean') {\n      recoursive = pattern;\n      pattern = undefined;\n    }\n\n    var files = [];\n    fs.readdirSync(root).forEach(function (file) {\n      var path = pth.join(root, file);\n      if (fs.statSync(path).isDirectory() && recoursive) files = files.concat(findSync(path, pattern, recoursive));\n\n      if (!pattern || pattern.test(path)) {\n        files.push(pth.normalize(path) + (fs.statSync(path).isDirectory() ? PATH_SEPARATOR : \"\"));\n      }\n    });\n    return files;\n  }\n\n  return {\n    makeDir: function makeDir(\n    /*String*/\n    path) {\n      mkdirSync(path);\n    },\n    crc32: function crc32(buf) {\n      var b = new Buffer(4);\n\n      if (!crcTable.length) {\n        for (var n = 0; n < 256; n++) {\n          var c = n;\n\n          for (var k = 8; --k >= 0;) {\n            //\n            if ((c & 1) != 0) {\n              c = 0xedb88320 ^ c >>> 1;\n            } else {\n              c = c >>> 1;\n            }\n          }\n\n          if (c < 0) {\n            b.writeInt32LE(c, 0);\n            c = b.readUInt32LE(0);\n          }\n\n          crcTable[n] = c;\n        }\n      }\n\n      var crc = 0,\n          off = 0,\n          len = buf.length,\n          c1 = ~crc;\n\n      while (--len >= 0) {\n        c1 = crcTable[(c1 ^ buf[off++]) & 0xff] ^ c1 >>> 8;\n      }\n\n      crc = ~c1;\n      b.writeInt32LE(crc & 0xffffffff, 0);\n      return b.readUInt32LE(0);\n    },\n    methodToString: function methodToString(\n    /*Number*/\n    method) {\n      switch (method) {\n        case Constants.STORED:\n          return 'STORED (' + method + ')';\n\n        case Constants.DEFLATED:\n          return 'DEFLATED (' + method + ')';\n\n        default:\n          return 'UNSUPPORTED (' + method + ')';\n      }\n    },\n    writeFileTo: function writeFileTo(\n    /*String*/\n    path,\n    /*Buffer*/\n    content,\n    /*Boolean*/\n    overwrite,\n    /*Number*/\n    attr) {\n      if (fs.existsSync(path)) {\n        if (!overwrite) return false; // cannot overwite\n\n        var stat = fs.statSync(path);\n\n        if (stat.isDirectory()) {\n          return false;\n        }\n      }\n\n      var folder = pth.dirname(path);\n\n      if (!fs.existsSync(folder)) {\n        mkdirSync(folder);\n      }\n\n      var fd;\n\n      try {\n        fd = fs.openSync(path, 'w', 438); // 0666\n      } catch (e) {\n        fs.chmodSync(path, 438);\n        fd = fs.openSync(path, 'w', 438);\n      }\n\n      if (fd) {\n        fs.writeSync(fd, content, 0, content.length, 0);\n        fs.closeSync(fd);\n      }\n\n      fs.chmodSync(path, attr || 438);\n      return true;\n    },\n    findFiles: function findFiles(\n    /*String*/\n    path) {\n      return findSync(path, true);\n    },\n    getAttributes: function getAttributes(\n    /*String*/\n    path) {},\n    setAttributes: function setAttributes(\n    /*String*/\n    path) {},\n    toBuffer: function toBuffer(input) {\n      if (Buffer.isBuffer(input)) {\n        return input;\n      } else {\n        if (input.length == 0) {\n          return new Buffer(0);\n        }\n\n        return new Buffer(input, 'utf8');\n      }\n    },\n    Constants: Constants,\n    Errors: Errors\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}