{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\").default;\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _inherits = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/inherits\").default;\n\nvar _createSuper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createSuper\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar semver = require(\"semver\");\n\nvar config_1 = require(\"../config\");\n\nvar http_utils_1 = require(\"../http_utils\");\n\nvar config_source_1 = require(\"./config_source\");\n\nvar ChromeXml = /*#__PURE__*/function (_config_source_1$XmlC) {\n  _inherits(ChromeXml, _config_source_1$XmlC);\n\n  var _super = _createSuper(ChromeXml);\n\n  function ChromeXml() {\n    var _this;\n\n    _classCallCheck(this, ChromeXml);\n\n    _this = _super.call(this, 'chrome', config_1.Config.cdnUrls()['chrome']);\n    _this.maxVersion = config_1.Config.binaryVersions().maxChrome;\n    return _this;\n  }\n\n  _createClass(ChromeXml, [{\n    key: \"getUrl\",\n    value: function getUrl(version) {\n      if (version === 'latest') {\n        return this.getLatestChromeDriverVersion();\n      } else {\n        return this.getSpecificChromeDriverVersion(version);\n      }\n    }\n    /**\n     * Get a list of chrome drivers paths available for the configuration OS type and architecture.\n     */\n\n  }, {\n    key: \"getVersionList\",\n    value: function getVersionList() {\n      var _this2 = this;\n\n      return this.getXml().then(function (xml) {\n        var versionPaths = [];\n\n        var osType = _this2.getOsTypeName();\n\n        var _iterator = _createForOfIteratorHelper(xml.ListBucketResult.Contents),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var content = _step.value;\n            var contentKey = content.Key[0];\n\n            if ( // Filter for 32-bit devices, make sure x64 is not an option\n            (_this2.osarch.includes('64') || !contentKey.includes('64')) && ( // Filter for x86 macs, make sure m1 is not an option\n            _this2.ostype === 'Darwin' && _this2.osarch === 'arm64' || !contentKey.includes('m1'))) {\n              // Filter for only the osType\n              if (contentKey.includes(osType)) {\n                versionPaths.push(contentKey);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return versionPaths;\n      });\n    }\n    /**\n     * Helper method, gets the ostype and gets the name used by the XML\n     */\n\n  }, {\n    key: \"getOsTypeName\",\n    value: function getOsTypeName() {\n      // Get the os type name.\n      if (this.ostype === 'Darwin') {\n        return 'mac';\n      } else if (this.ostype === 'Windows_NT') {\n        return 'win';\n      } else {\n        return 'linux';\n      }\n    }\n    /**\n     * Gets the latest item from the XML.\n     */\n\n  }, {\n    key: \"getLatestChromeDriverVersion\",\n    value: function getLatestChromeDriverVersion() {\n      var _this3 = this;\n\n      var latestReleaseUrl = 'https://chromedriver.storage.googleapis.com/LATEST_RELEASE';\n      return http_utils_1.requestBody(latestReleaseUrl).then(function (latestVersion) {\n        return _this3.getSpecificChromeDriverVersion(latestVersion);\n      });\n    }\n    /**\n     * Gets a specific item from the XML.\n     */\n\n  }, {\n    key: \"getSpecificChromeDriverVersion\",\n    value: function getSpecificChromeDriverVersion(inputVersion) {\n      var _this4 = this;\n\n      return this.getVersionList().then(function (list) {\n        var specificVersion = getValidSemver(inputVersion);\n\n        if (specificVersion === '') {\n          throw new Error(\"version \".concat(inputVersion, \" ChromeDriver does not exist\"));\n        }\n\n        var itemFound = '';\n\n        var _iterator2 = _createForOfIteratorHelper(list),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var item = _step2.value;\n            // Get a semantic version.\n            var version = item.split('/')[0];\n\n            if (semver.valid(version) == null) {\n              var lookUpVersion = getValidSemver(version);\n\n              if (semver.valid(lookUpVersion)) {\n                // Check to see if the specified version matches.\n                if (lookUpVersion === specificVersion) {\n                  // When item found is null, check the os arch\n                  // 64-bit version works OR not 64-bit version and the path does not have '64'\n                  if (itemFound == '') {\n                    if (_this4.osarch === 'x64' || _this4.osarch !== 'x64' && !item.includes(_this4.getOsTypeName() + '64')) {\n                      itemFound = item;\n                    }\n\n                    if (_this4.osarch === 'arm64' && _this4.ostype === 'Darwin' && item.includes('m1')) {\n                      itemFound = item;\n                    }\n                  } else if (_this4.osarch === 'x64') {\n                    // No win64 version exists, so even on x64 we need to look for win32\n                    var osTypeNameAndArch = _this4.getOsTypeName() + (_this4.getOsTypeName() === 'win' ? '32' : '64');\n\n                    if (item.includes(osTypeNameAndArch)) {\n                      itemFound = item;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (itemFound == '') {\n          return {\n            url: '',\n            version: inputVersion\n          };\n        } else {\n          return {\n            url: config_1.Config.cdnUrls().chrome + itemFound,\n            version: inputVersion\n          };\n        }\n      });\n    }\n  }]);\n\n  return ChromeXml;\n}(config_source_1.XmlConfigSource);\n\nexports.ChromeXml = ChromeXml;\n/**\n * Chromedriver is the only binary that does not conform to semantic versioning\n * and either has too little number of digits or too many. To get this to be in\n * semver, we will either add a '.0' at the end or chop off the last set of\n * digits. This is so we can compare to find the latest and greatest.\n *\n * Example:\n *   2.46 -> 2.46.0\n *   75.0.3770.8 -> 75.0.3770\n *\n * @param version\n */\n\nfunction getValidSemver(version) {\n  var lookUpVersion = ''; // This supports downloading 2.46\n\n  try {\n    var oldRegex = /(\\d+.\\d+)/g;\n    var exec = oldRegex.exec(version);\n\n    if (exec) {\n      lookUpVersion = exec[1] + '.0';\n    }\n  } catch (_) {// no-op: is this is not valid, do not throw here.\n  } // This supports downloading 74.0.3729.6\n\n\n  try {\n    var newRegex = /(\\d+.\\d+.\\d+).\\d+/g;\n\n    var _exec = newRegex.exec(version);\n\n    if (_exec) {\n      lookUpVersion = _exec[1];\n    }\n  } catch (_) {// no-op: if this does not work, use the other regex pattern.\n  }\n\n  return lookUpVersion;\n}\n\nexports.getValidSemver = getValidSemver; //# sourceMappingURL=chrome_xml.js.map","map":null,"metadata":{},"sourceType":"script"}