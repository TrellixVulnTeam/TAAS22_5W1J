{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\").default;\n\nvar _classCallCheck = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar _createClass = require(\"/Users/pier/Desktop/Progetto/taass/src/main/js/ecommerce/node_modules/@babel/runtime/helpers/createClass\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar request = require(\"request\");\n\nvar url = require(\"url\");\n\nvar logger_1 = require(\"./cli/logger\");\n\nvar config_1 = require(\"./config\");\n\nvar logger = new logger_1.Logger('http_utils');\n\nvar HttpUtils = /*#__PURE__*/function () {\n  function HttpUtils() {\n    _classCallCheck(this, HttpUtils);\n  }\n\n  _createClass(HttpUtils, null, [{\n    key: \"assignOptions\",\n    value: function assignOptions(options) {\n      Object.assign(HttpUtils.requestOpts, options);\n    }\n  }, {\n    key: \"initOptions\",\n    value: function initOptions(url, timeout) {\n      var options = {\n        url: url,\n        // default Linux can be anywhere from 20-120 seconds\n        // increasing this arbitrarily to 4 minutes\n        timeout: 240000\n      };\n      HttpUtils.optionsSSL(options, HttpUtils.requestOpts.ignoreSSL);\n      HttpUtils.optionsProxy(options, url, HttpUtils.requestOpts.proxy);\n      return options;\n    }\n  }, {\n    key: \"optionsSSL\",\n    value: function optionsSSL(options, opt_ignoreSSL) {\n      if (opt_ignoreSSL) {\n        logger.info('ignoring SSL certificate');\n        options.strictSSL = !opt_ignoreSSL;\n        options.rejectUnauthorized = !opt_ignoreSSL;\n      }\n\n      return options;\n    }\n  }, {\n    key: \"optionsProxy\",\n    value: function optionsProxy(options, requestUrl, opt_proxy) {\n      if (opt_proxy) {\n        options.proxy = HttpUtils.resolveProxy(requestUrl, opt_proxy);\n\n        if (url.parse(requestUrl).protocol === 'https:') {\n          options.url = requestUrl.replace('https:', 'http:');\n        }\n      }\n\n      return options;\n    }\n  }, {\n    key: \"optionsHeader\",\n    value: function optionsHeader(options, key, value) {\n      if (options.headers == null) {\n        options.headers = {};\n      }\n\n      options.headers[key] = value;\n      return options;\n    }\n    /**\n     * Resolves proxy based on values set\n     * @param fileUrl The url to download the file.\n     * @param opt_proxy The proxy to connect to to download files.\n     * @return Either undefined or the proxy.\n     */\n\n  }, {\n    key: \"resolveProxy\",\n    value: function resolveProxy(fileUrl, opt_proxy) {\n      var protocol = url.parse(fileUrl).protocol;\n      var hostname = url.parse(fileUrl).hostname;\n\n      if (opt_proxy) {\n        return opt_proxy;\n      } else {\n        // If the NO_PROXY environment variable exists and matches the host name,\n        // to ignore the resolve proxy.\n        // the checks to see if it exists and equal to empty string is to help with testing\n        var noProxy = config_1.Config.noProxy();\n\n        if (noProxy) {\n          // array of hostnames/domain names listed in the NO_PROXY environment variable\n          var noProxyTokens = noProxy.split(','); // check if the fileUrl hostname part does not end with one of the\n          // NO_PROXY environment variable's hostnames/domain names\n\n          var _iterator = _createForOfIteratorHelper(noProxyTokens),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var noProxyToken = _step.value;\n\n              if (hostname.indexOf(noProxyToken) !== -1) {\n                return undefined;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } // If the HTTPS_PROXY and HTTP_PROXY environment variable is set, use that as the proxy\n\n\n        if (protocol === 'https:') {\n          return config_1.Config.httpsProxy() || config_1.Config.httpProxy();\n        } else if (protocol === 'http:') {\n          return config_1.Config.httpProxy();\n        }\n      }\n\n      return undefined;\n    }\n  }]);\n\n  return HttpUtils;\n}();\n\nHttpUtils.requestOpts = {};\nexports.HttpUtils = HttpUtils;\n/**\n * Request the body from the url.\n * @param requestUrl The request url.\n * @returns A promise string of the response body.\n */\n\nfunction requestBody(requestUrl) {\n  var options = HttpUtils.initOptions(requestUrl);\n  options.followRedirect = true;\n  return new Promise(function (resolve, reject) {\n    var req = request(options);\n    req.on('response', function (response) {\n      if (response.statusCode === 200) {\n        var output = '';\n        response.on('data', function (data) {\n          output += data;\n        });\n        response.on('end', function () {\n          resolve(output);\n        });\n      } else {\n        reject(new Error('response status code is not 200'));\n      }\n    });\n    req.on('error', function (error) {\n      reject(error);\n    });\n  });\n}\n\nexports.requestBody = requestBody; //# sourceMappingURL=http_utils.js.map","map":null,"metadata":{},"sourceType":"script"}